<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.16: http://docutils.sourceforge.net/" />
<title>reference-Core.rst</title>
<meta name="author" content="Arvid Norberg, arvid&#64;libtorrent.org" />
<meta name=viewport content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="style.css" type="text/css" />
<link rel="stylesheet" type="text/css" href="rst.css" />
<style type="text/css">
/* Hides from IE-mac \*/
* html pre { height: 1%; }
/* End hide from IE-mac */
</style>
</head>
<body>
<div class="document">
    <div id="container">
    <a href="index.html"><table id="header">
    <tr><td id="orange"></td>
    <td id="logo">libtorrent</td></tr>
    </table></a>
    <div id="main">

<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Arvid Norberg, <a class="last reference external" href="mailto:arvid&#64;libtorrent.org">arvid&#64;libtorrent.org</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1.2.8</td></tr>
</tbody>
</table>
<p><a class="reference external" href="reference.html">home</a></p>
<div class="section" id="core">
<h1>Core</h1>
<div class="contents topic" id="table-of-contents">
<p class="topic-title">Table of contents</p>
<ul class="simple">
<li><a class="reference internal" href="#core" id="id258">Core</a><ul>
<li><a class="reference internal" href="#peer-class-info" id="id259">peer_class_info</a></li>
<li><a class="reference internal" href="#peer-connection-handle" id="id260">peer_connection_handle</a></li>
<li><a class="reference internal" href="#bt-peer-connection-handle" id="id261">bt_peer_connection_handle</a></li>
<li><a class="reference internal" href="#torrent-status" id="id262">torrent_status</a></li>
<li><a class="reference internal" href="#announce-endpoint" id="id263">announce_endpoint</a></li>
<li><a class="reference internal" href="#announce-entry" id="id264">announce_entry</a></li>
<li><a class="reference internal" href="#open-file-state" id="id265">open_file_state</a></li>
<li><a class="reference internal" href="#peer-class-type-filter" id="id266">peer_class_type_filter</a></li>
<li><a class="reference internal" href="#block-info" id="id267">block_info</a></li>
<li><a class="reference internal" href="#partial-piece-info" id="id268">partial_piece_info</a></li>
<li><a class="reference internal" href="#torrent-handle" id="id269">torrent_handle</a></li>
<li><a class="reference internal" href="#cache-status" id="id270">cache_status</a></li>
<li><a class="reference internal" href="#web-seed-entry" id="id271">web_seed_entry</a></li>
<li><a class="reference internal" href="#load-torrent-limits" id="id272">load_torrent_limits</a></li>
<li><a class="reference internal" href="#torrent-info" id="id273">torrent_info</a></li>
<li><a class="reference internal" href="#add-torrent-params" id="id274">add_torrent_params</a></li>
<li><a class="reference internal" href="#peer-info" id="id275">peer_info</a></li>
<li><a class="reference internal" href="#peer-request" id="id276">peer_request</a></li>
<li><a class="reference internal" href="#write-resume-data-write-resume-data-buf" id="id277">write_resume_data() write_resume_data_buf()</a></li>
<li><a class="reference internal" href="#make-magnet-uri" id="id278">make_magnet_uri()</a></li>
<li><a class="reference internal" href="#parse-magnet-uri" id="id279">parse_magnet_uri()</a></li>
<li><a class="reference internal" href="#version" id="id280">version()</a></li>
<li><a class="reference internal" href="#generate-fingerprint" id="id281">generate_fingerprint()</a></li>
<li><a class="reference internal" href="#hash-value" id="id282">hash_value()</a></li>
<li><a class="reference internal" href="#is-utp-stream-logging" id="id283">is_utp_stream_logging()</a></li>
<li><a class="reference internal" href="#set-utp-stream-logging" id="id284">set_utp_stream_logging()</a></li>
<li><a class="reference internal" href="#read-resume-data" id="id285">read_resume_data()</a></li>
<li><a class="reference internal" href="#enum-connection-type" id="id286">enum connection_type</a></li>
<li><a class="reference internal" href="#enum-portmap-transport" id="id287">enum portmap_transport</a></li>
<li><a class="reference internal" href="#enum-portmap-protocol" id="id288">enum portmap_protocol</a></li>
<li><a class="reference internal" href="#torrent-flags-t" id="id289">torrent_flags_t</a></li>
<li><a class="reference internal" href="#download-priority-t" id="id290">download_priority_t</a></li>
<li><a class="reference internal" href="#pex-flags-t" id="id291">pex_flags_t</a></li>
<li><a class="reference internal" href="#file-open-mode-t" id="id292">file_open_mode_t</a></li>
<li><a class="reference internal" href="#open-mode-t" id="id293">open_mode_t</a></li>
</ul>
</li>
</ul>
</div>
<a name="peer_class_info"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_class_info&labels=documentation&body=Documentation+under+heading+%22class+peer_class_info%22+could+be+improved">report issue</a>]</span><div class="section" id="peer-class-info">
<h2>peer_class_info</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_class.hpp">libtorrent/peer_class.hpp</a>&quot;</p>
<p>holds settings for a peer class. Used in <a class="reference external" href="reference-Session.html#set_peer_class()">set_peer_class()</a> and
<a class="reference external" href="reference-Session.html#get_peer_class()">get_peer_class()</a> calls.</p>
<pre class="literal-block">
struct peer_class_info
{
   bool ignore_unchoke_slots;
   int connection_limit_factor;
   std::string label;
   int upload_limit;
   int download_limit;
   int upload_priority;
   int download_priority;
};
</pre>
<a name="ignore_unchoke_slots"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Bignore_unchoke_slots%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Bignore_unchoke_slots%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ignore_unchoke_slots</dt>
<dd><tt class="docutils literal">ignore_unchoke_slots</tt> determines whether peers should always
unchoke a peer, regardless of the choking algorithm, or if it should
honor the unchoke slot limits. It's used for local peers by default.
If <em>any</em> of the peer classes a peer belongs to has this set to true,
that peer will be unchoked at all times.</dd>
</dl>
<a name="connection_limit_factor"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Bconnection_limit_factor%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Bconnection_limit_factor%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connection_limit_factor</dt>
<dd>adjusts the connection limit (global and per torrent) that applies to
this peer class. By default, local peers are allowed to exceed the
normal connection limit for instance. This is specified as a percent
factor. 100 makes the peer class apply normally to the limit. 200
means as long as there are fewer connections than twice the limit, we
accept this peer. This factor applies both to the global connection
limit and the per-torrent limit. Note that if not used carefully one
peer class can potentially completely starve out all other over time.</dd>
</dl>
<a name="label"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Blabel%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Blabel%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>label</dt>
<dd>not used by libtorrent. It's intended as a potentially user-facing
identifier of this peer class.</dd>
</dl>
<a name="upload_limit"></a>
<a name="download_limit"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Bupload_limit+download_limit%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Bupload_limit+download_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_limit download_limit</dt>
<dd>transfer rates limits for the whole peer class. They are specified in
bytes per second and apply to the sum of all peers that are members of
this class.</dd>
</dl>
<a name="upload_priority"></a>
<a name="download_priority"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_info%3A%3A%5Bupload_priority+download_priority%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_info%3A%3A%5Bupload_priority+download_priority%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_priority download_priority</dt>
<dd>relative priorities used by the bandwidth allocator in the rate
limiter. If no rate limits are in use, the priority is not used
either. Priorities start at 1 (0 is not a valid priority) and may not
exceed 255.</dd>
</dl>
<a name="peer_connection_handle"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_connection_handle&labels=documentation&body=Documentation+under+heading+%22class+peer_connection_handle%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-connection-handle">
<h2>peer_connection_handle</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_connection_handle.hpp">libtorrent/peer_connection_handle.hpp</a>&quot;</p>
<p>the <a class="reference external" href="reference-Core.html#peer_connection_handle">peer_connection_handle</a> class provides a handle to the internal peer
connection object, to be used by plugins. This is a low level interface that
may not be stable across libtorrent versions</p>
<pre class="literal-block">
struct peer_connection_handle
{
   explicit <strong>peer_connection_handle</strong> (std::weak_ptr&lt;peer_connection&gt; impl);
   connection_type <strong>type</strong> () const;
   void <strong>add_extension</strong> (std::shared_ptr&lt;peer_plugin&gt;);
   peer_plugin const* <strong>find_plugin</strong> (string_view type) const;
   bool <strong>is_seed</strong> () const;
   bool <strong>upload_only</strong> () const;
   bool <strong>has_piece</strong> (piece_index_t i) const;
   peer_id const&amp; <strong>pid</strong> () const;
   bool <strong>is_choked</strong> () const;
   bool <strong>is_interesting</strong> () const;
   bool <strong>is_peer_interested</strong> () const;
   bool <strong>has_peer_choked</strong> () const;
   void <strong>maybe_unchoke_this_peer</strong> ();
   void <strong>choke_this_peer</strong> ();
   void <strong>get_peer_info</strong> (peer_info&amp; p) const;
   torrent_handle <strong>associated_torrent</strong> () const;
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> <strong>local_endpoint</strong> () const;
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> const&amp; <strong>remote</strong> () const;
   bool <strong>is_outgoing</strong> () const;
   void <strong>disconnect</strong> (error_code const&amp; ec, operation_t op
      , disconnect_severity_t = peer_connection_interface::normal);
   bool <strong>is_connecting</strong> () const;
   bool <strong>is_disconnecting</strong> () const;
   bool <strong>ignore_unchoke_slots</strong> () const;
   bool <strong>on_local_network</strong> () const;
   bool <strong>failed</strong> () const;
   bool <strong>should_log</strong> (peer_log_alert::direction_t direction) const;
   void <strong>peer_log</strong> (peer_log_alert::direction_t direction
      , char const* event, char const* fmt = &quot;&quot;, ...) const TORRENT_FORMAT(4,5);
   bool <strong>can_disconnect</strong> (error_code const&amp; ec) const;
   bool <strong>has_metadata</strong> () const;
   bool <strong>in_handshake</strong> () const;
   void <strong>send_buffer</strong> (char const* begin, int size);
   time_point <strong>time_of_last_unchoke</strong> () const;
   std::time_t <strong>last_seen_complete</strong> () const;
   bool <strong>operator==</strong> (peer_connection_handle const&amp; o) const;
   bool <strong>operator&lt;</strong> (peer_connection_handle const&amp; o) const;
   bool <strong>operator!=</strong> (peer_connection_handle const&amp; o) const;
   std::shared_ptr&lt;peer_connection&gt; <strong>native_handle</strong> () const;
};
</pre>
<a name="bt_peer_connection_handle"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+bt_peer_connection_handle&labels=documentation&body=Documentation+under+heading+%22class+bt_peer_connection_handle%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="bt-peer-connection-handle">
<h2>bt_peer_connection_handle</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_connection_handle.hpp">libtorrent/peer_connection_handle.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Core.html#bt_peer_connection_handle">bt_peer_connection_handle</a> provides a handle to the internal bittorrent
peer connection object to plugins. It's low level and may not be a stable API
across libtorrent versions.</p>
<pre class="literal-block">
struct bt_peer_connection_handle : peer_connection_handle
{
   explicit <strong>bt_peer_connection_handle</strong> (peer_connection_handle pc);
   bool <strong>support_extensions</strong> () const;
   bool <strong>packet_finished</strong> () const;
   bool <strong>supports_encryption</strong> () const;
   void <strong>switch_recv_crypto</strong> (std::shared_ptr&lt;crypto_plugin&gt; crypto);
   void <strong>switch_send_crypto</strong> (std::shared_ptr&lt;crypto_plugin&gt; crypto);
   std::shared_ptr&lt;bt_peer_connection&gt; <strong>native_handle</strong> () const;
};
</pre>
<a name="torrent_status"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_status&labels=documentation&body=Documentation+under+heading+%22class+torrent_status%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-status">
<h2>torrent_status</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_status.hpp">libtorrent/torrent_status.hpp</a>&quot;</p>
<p>holds a snapshot of the status of a torrent, as queried by
<a class="reference external" href="reference-Core.html#status()">torrent_handle::status()</a>.</p>
<pre class="literal-block">
struct torrent_status
{
   bool <strong>operator==</strong> (torrent_status const&amp; st) const;
   time_duration next_announce = <strong>seconds</strong> (0);

   enum state_t
   {
      checking_files,
      downloading_metadata,
      downloading,
      finished,
      seeding,
      allocating,
      checking_resume_data,
   };

   torrent_handle handle;
   error_code errc;
   file_index_t <strong>error_file</strong>  = torrent_status::error_file_none;
   static constexpr file_index_t <strong>error_file_none</strong> {-1};
   static constexpr file_index_t <strong>error_file_ssl_ctx</strong> {-3};
   static constexpr file_index_t <strong>error_file_metadata</strong> {-4};
   static constexpr file_index_t <strong>error_file_exception</strong> {-5};
   static constexpr file_index_t <strong>error_file_partfile</strong> {-6};
   std::string save_path;
   std::string name;
   std::weak_ptr&lt;const torrent_info&gt; torrent_file;
   std::string current_tracker;
   std::int64_t <strong>total_download</strong>  = 0;
   std::int64_t <strong>total_upload</strong>  = 0;
   std::int64_t <strong>total_payload_download</strong>  = 0;
   std::int64_t <strong>total_payload_upload</strong>  = 0;
   std::int64_t <strong>total_failed_bytes</strong>  = 0;
   std::int64_t <strong>total_redundant_bytes</strong>  = 0;
   typed_bitfield&lt;piece_index_t&gt; pieces;
   typed_bitfield&lt;piece_index_t&gt; verified_pieces;
   std::int64_t <strong>total_done</strong>  = 0;
   std::int64_t <strong>total</strong>  = 0;
   std::int64_t <strong>total_wanted_done</strong>  = 0;
   std::int64_t <strong>total_wanted</strong>  = 0;
   std::int64_t <strong>all_time_upload</strong>  = 0;
   std::int64_t <strong>all_time_download</strong>  = 0;
   std::time_t <strong>added_time</strong>  = 0;
   std::time_t <strong>completed_time</strong>  = 0;
   std::time_t <strong>last_seen_complete</strong>  = 0;
   storage_mode_t <strong>storage_mode</strong>  = storage_mode_sparse;
   float <strong>progress</strong>  = 0.f;
   int <strong>progress_ppm</strong>  = 0;
   queue_position_t <strong>queue_position</strong> {};
   int <strong>download_rate</strong>  = 0;
   int <strong>upload_rate</strong>  = 0;
   int <strong>download_payload_rate</strong>  = 0;
   int <strong>upload_payload_rate</strong>  = 0;
   int <strong>num_seeds</strong>  = 0;
   int <strong>num_peers</strong>  = 0;
   int <strong>num_complete</strong>  = -1;
   int <strong>num_incomplete</strong>  = -1;
   int <strong>list_seeds</strong>  = 0;
   int <strong>list_peers</strong>  = 0;
   int <strong>connect_candidates</strong>  = 0;
   int <strong>num_pieces</strong>  = 0;
   int <strong>distributed_full_copies</strong>  = 0;
   int <strong>distributed_fraction</strong>  = 0;
   float <strong>distributed_copies</strong>  = 0.f;
   int <strong>block_size</strong>  = 0;
   int <strong>num_uploads</strong>  = 0;
   int <strong>num_connections</strong>  = 0;
   int <strong>uploads_limit</strong>  = 0;
   int <strong>connections_limit</strong>  = 0;
   int <strong>up_bandwidth_queue</strong>  = 0;
   int <strong>down_bandwidth_queue</strong>  = 0;
   int <strong>seed_rank</strong>  = 0;
   state_t <strong>state</strong>  = checking_resume_data;
   bool <strong>need_save_resume</strong>  = false;
   bool <strong>is_seeding</strong>  = false;
   bool <strong>is_finished</strong>  = false;
   bool <strong>has_metadata</strong>  = false;
   bool <strong>has_incoming</strong>  = false;
   bool <strong>moving_storage</strong>  = false;
   bool <strong>announcing_to_trackers</strong>  = false;
   bool <strong>announcing_to_lsd</strong>  = false;
   bool <strong>announcing_to_dht</strong>  = false;
   sha1_hash info_hash;
   time_point last_upload;
   time_point last_download;
   seconds active_duration;
   seconds finished_duration;
   seconds seeding_duration;
   torrent_flags_t <strong>flags</strong> {};
};
</pre>
<a name="operator==()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Boperator%3D%3D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Boperator%3D%3D%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator">
<h3>operator==()</h3>
<pre class="literal-block">
bool <strong>operator==</strong> (torrent_status const&amp; st) const;
</pre>
<p>compares if the torrent status objects come from the same torrent. i.e.
only the <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a> field is compared.</p>
<a name="seconds()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bseconds%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bseconds%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="seconds">
<h3>seconds()</h3>
<pre class="literal-block">
time_duration next_announce = <strong>seconds</strong> (0);
</pre>
<p>the time until the torrent will announce itself to the tracker.</p>
<a name="state_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+state_t&labels=documentation&body=Documentation+under+heading+%22enum+state_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-state-t">
<h3>enum state_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_status.hpp">libtorrent/torrent_status.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="8%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>checking_files</td>
<td>1</td>
<td>The torrent has not started its download yet, and is
currently checking existing files.</td>
</tr>
<tr><td>downloading_metadata</td>
<td>2</td>
<td>The torrent is trying to download metadata from peers.
This implies the ut_metadata extension is in use.</td>
</tr>
<tr><td>downloading</td>
<td>3</td>
<td>The torrent is being downloaded. This is the state
most torrents will be in most of the time. The progress
meter will tell how much of the files that has been
downloaded.</td>
</tr>
<tr><td>finished</td>
<td>4</td>
<td>In this state the torrent has finished downloading but
still doesn't have the entire torrent. i.e. some pieces
are filtered and won't get downloaded.</td>
</tr>
<tr><td>seeding</td>
<td>5</td>
<td>In this state the torrent has finished downloading and
is a pure seeder.</td>
</tr>
<tr><td>allocating</td>
<td>6</td>
<td>If the torrent was started in full allocation mode, this
indicates that the (disk) storage for the torrent is
allocated.</td>
</tr>
<tr><td>checking_resume_data</td>
<td>7</td>
<td>The torrent is currently checking the fast resume data and
comparing it to the files on disk. This is typically
completed in a fraction of a second, but if you add a
large number of torrents at once, they will queue up.</td>
</tr>
</tbody>
</table>
<a name="handle"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bhandle%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bhandle%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>handle</dt>
<dd>a handle to the torrent whose status the object represents.</dd>
</dl>
<a name="errc"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berrc%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berrc%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>errc</dt>
<dd>may be set to an error code describing why the torrent was paused, in
case it was paused by an error. If the torrent is not paused or if it's
paused but not because of an error, this error_code is not set.
if the error is attributed specifically to a file, error_file is set to
the index of that file in the .torrent file.</dd>
</dl>
<a name="error_file"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file</dt>
<dd>if the torrent is stopped because of an disk I/O error, this field
contains the index of the file in the torrent that encountered the
error. If the error did not originate in a file in the torrent, there
are a few special values this can be set to: error_file_none,
error_file_ssl_ctx, error_file_exception, error_file_partfile or
error_file_metadata;</dd>
</dl>
<a name="error_file_none"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_none%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_none%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_none</dt>
<dd>special values for error_file to describe which file or component
encountered the error (<tt class="docutils literal">errc</tt>).
the error did not occur on a file</dd>
</dl>
<a name="error_file_ssl_ctx"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_ssl_ctx%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_ssl_ctx%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_ssl_ctx</dt>
<dd>the error occurred setting up the SSL context</dd>
</dl>
<a name="error_file_metadata"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_metadata%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_metadata%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_metadata</dt>
<dd>the error occurred while loading the .torrent file via the user
supplied load function</dd>
</dl>
<a name="error_file_exception"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_exception%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_exception%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_exception</dt>
<dd>there was a serious error reported in this torrent. The error code
or a torrent log <a class="reference external" href="reference-Alerts.html#alert">alert</a> may provide more information.</dd>
</dl>
<a name="error_file_partfile"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Berror_file_partfile%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Berror_file_partfile%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>error_file_partfile</dt>
<dd>the error occurred with the partfile</dd>
</dl>
<a name="save_path"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bsave_path%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bsave_path%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_path</dt>
<dd>the path to the directory where this torrent's files are stored.
It's typically the path as was given to <a class="reference external" href="reference-Session.html#async_add_torrent()">async_add_torrent()</a> or
<a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> when this torrent was started. This field is only
included if the torrent status is queried with
<tt class="docutils literal"><span class="pre">torrent_handle::query_save_path</span></tt>.</dd>
</dl>
<a name="name"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bname%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bname%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>name</dt>
<dd>the name of the torrent. Typically this is derived from the
.torrent file. In case the torrent was started without metadata,
and hasn't completely received it yet, it returns the name given
to it when added to the <a class="reference external" href="reference-Session.html#session">session</a>. See <tt class="docutils literal"><span class="pre">session::add_torrent</span></tt>.
This field is only included if the torrent status is queried
with <tt class="docutils literal"><span class="pre">torrent_handle::query_name</span></tt>.</dd>
</dl>
<a name="torrent_file"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btorrent_file%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btorrent_file%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>torrent_file</dt>
<dd>set to point to the <tt class="docutils literal">torrent_info</tt> object for this torrent. It's
only included if the torrent status is queried with
<tt class="docutils literal"><span class="pre">torrent_handle::query_torrent_file</span></tt>.</dd>
</dl>
<a name="current_tracker"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bcurrent_tracker%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bcurrent_tracker%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>current_tracker</dt>
<dd>the URL of the last working tracker. If no tracker request has
been successful yet, it's set to an empty string.</dd>
</dl>
<a name="total_download"></a>
<a name="total_upload"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_download+total_upload%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_download+total_upload%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_download total_upload</dt>
<dd>the number of bytes downloaded and uploaded to all peers, accumulated,
<em>this session</em> only. The <a class="reference external" href="reference-Session.html#session">session</a> is considered to restart when a
torrent is paused and restarted again. When a torrent is paused, these
counters are reset to 0. If you want complete, persistent, stats, see
<tt class="docutils literal">all_time_upload</tt> and <tt class="docutils literal">all_time_download</tt>.</dd>
</dl>
<a name="total_payload_download"></a>
<a name="total_payload_upload"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_payload_download+total_payload_upload%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_payload_download+total_payload_upload%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_payload_download total_payload_upload</dt>
<dd>counts the amount of bytes send and received this <a class="reference external" href="reference-Session.html#session">session</a>, but only
the actual payload data (i.e the interesting data), these counters
ignore any protocol overhead. The <a class="reference external" href="reference-Session.html#session">session</a> is considered to restart
when a torrent is paused and restarted again. When a torrent is
paused, these counters are reset to 0.</dd>
</dl>
<a name="total_failed_bytes"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_failed_bytes%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_failed_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_failed_bytes</dt>
<dd>the number of bytes that has been downloaded and that has failed the
piece hash test. In other words, this is just how much crap that has
been downloaded since the torrent was last started. If a torrent is
paused and then restarted again, this counter will be reset.</dd>
</dl>
<a name="total_redundant_bytes"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_redundant_bytes%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_redundant_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_redundant_bytes</dt>
<dd>the number of bytes that has been downloaded even though that data
already was downloaded. The reason for this is that in some situations
the same data can be downloaded by mistake. When libtorrent sends
requests to a peer, and the peer doesn't send a response within a
certain timeout, libtorrent will re-request that block. Another
situation when libtorrent may re-request blocks is when the requests
it sends out are not replied in FIFO-order (it will re-request blocks
that are skipped by an out of order block). This is supposed to be as
low as possible. This only counts bytes since the torrent was last
started. If a torrent is paused and then restarted again, this counter
will be reset.</dd>
</dl>
<a name="pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bpieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bpieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pieces</dt>
<dd>a bitmask that represents which pieces we have (set to true) and the
pieces we don't have. It's a pointer and may be set to 0 if the
torrent isn't downloading or seeding.</dd>
</dl>
<a name="verified_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bverified_pieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bverified_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>verified_pieces</dt>
<dd>a bitmask representing which pieces has had their hash checked. This
only applies to torrents in <em>seed mode</em>. If the torrent is not in seed
mode, this bitmask may be empty.</dd>
</dl>
<a name="total_done"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_done%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_done%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_done</dt>
<dd>the total number of bytes of the file(s) that we have. All this does
not necessarily has to be downloaded during this <a class="reference external" href="reference-Session.html#session">session</a> (that's
<tt class="docutils literal">total_payload_download</tt>).</dd>
</dl>
<a name="total"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total</dt>
<dd>the total number of bytes to download for this torrent. This
may be less than the size of the torrent in case there are
pad files. This number only counts bytes that will actually
be requested from peers.</dd>
</dl>
<a name="total_wanted_done"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_wanted_done%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_wanted_done%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_wanted_done</dt>
<dd>the number of bytes we have downloaded, only counting the pieces that
we actually want to download. i.e. excluding any pieces that we have
but have priority 0 (i.e. not wanted).</dd>
</dl>
<a name="total_wanted"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Btotal_wanted%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Btotal_wanted%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_wanted</dt>
<dd>The total number of bytes we want to download. This may be smaller
than the total torrent size in case any pieces are prioritized to 0,
i.e.  not wanted</dd>
</dl>
<a name="all_time_upload"></a>
<a name="all_time_download"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Ball_time_upload+all_time_download%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Ball_time_upload+all_time_download%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>all_time_upload all_time_download</dt>
<dd>are accumulated upload and download payload byte counters. They are
saved in and restored from resume data to keep totals across sessions.</dd>
</dl>
<a name="added_time"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Badded_time%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Badded_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>added_time</dt>
<dd>the posix-time when this torrent was added. i.e. what <tt class="docutils literal">time(nullptr)</tt>
returned at the time.</dd>
</dl>
<a name="completed_time"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bcompleted_time%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bcompleted_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>completed_time</dt>
<dd>the posix-time when this torrent was finished. If the torrent is not
yet finished, this is 0.</dd>
</dl>
<a name="last_seen_complete"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Blast_seen_complete%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Blast_seen_complete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_seen_complete</dt>
<dd>the time when we, or one of our peers, last saw a complete copy of
this torrent.</dd>
</dl>
<a name="storage_mode"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bstorage_mode%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bstorage_mode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>storage_mode</dt>
<dd>The allocation mode for the torrent. See <a class="reference external" href="reference-Storage.html#storage_mode_t">storage_mode_t</a> for the
options. For more information, see <a class="reference external" href="manual-ref.html#storage-allocation">storage allocation</a>.</dd>
</dl>
<a name="progress"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bprogress%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bprogress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>progress</dt>
<dd>a value in the range [0, 1], that represents the progress of the
torrent's current task. It may be checking files or downloading.</dd>
</dl>
<a name="progress_ppm"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bprogress_ppm%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bprogress_ppm%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>progress_ppm</dt>
<dd><p class="first">progress parts per million (progress * 1000000) when disabling
floating point operations, this is the only option to query progress</p>
<p class="last">reflects the same value as <tt class="docutils literal">progress</tt>, but instead in a range [0,
1000000] (ppm = parts per million). When floating point operations are
disabled, this is the only alternative to the floating point value in
progress.</p>
</dd>
</dl>
<a name="queue_position"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bqueue_position%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bqueue_position%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>queue_position</dt>
<dd>the position this torrent has in the download
queue. If the torrent is a seed or finished, this is -1.</dd>
</dl>
<a name="download_rate"></a>
<a name="upload_rate"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdownload_rate+upload_rate%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdownload_rate+upload_rate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_rate upload_rate</dt>
<dd>the total rates for all peers for this torrent. These will usually
have better precision than summing the rates from all peers. The rates
are given as the number of bytes per second.</dd>
</dl>
<a name="download_payload_rate"></a>
<a name="upload_payload_rate"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdownload_payload_rate+upload_payload_rate%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdownload_payload_rate+upload_payload_rate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_payload_rate upload_payload_rate</dt>
<dd>the total transfer rate of payload only, not counting protocol
chatter. This might be slightly smaller than the other rates, but if
projected over a long time (e.g. when calculating ETA:s) the
difference may be noticeable.</dd>
</dl>
<a name="num_seeds"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_seeds%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_seeds%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_seeds</dt>
<dd>the number of peers that are seeding that this client is
currently connected to.</dd>
</dl>
<a name="num_peers"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_peers%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_peers</dt>
<dd>the number of peers this torrent currently is connected to. Peer
connections that are in the half-open state (is attempting to connect)
or are queued for later connection attempt do not count. Although they
are visible in the peer list when you call <a class="reference external" href="reference-Core.html#get_peer_info()">get_peer_info()</a>.</dd>
</dl>
<a name="num_complete"></a>
<a name="num_incomplete"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_complete+num_incomplete%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_complete+num_incomplete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_complete num_incomplete</dt>
<dd>if the tracker sends scrape info in its announce reply, these fields
will be set to the total number of peers that have the whole file and
the total number of peers that are still downloading. set to -1 if the
tracker did not send any scrape data in its announce reply.</dd>
</dl>
<a name="list_seeds"></a>
<a name="list_peers"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Blist_seeds+list_peers%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Blist_seeds+list_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>list_seeds list_peers</dt>
<dd>the number of seeds in our peer list and the total number of peers
(including seeds). We are not necessarily connected to all the peers
in our peer list. This is the number of peers we know of in total,
including banned peers and peers that we have failed to connect to.</dd>
</dl>
<a name="connect_candidates"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bconnect_candidates%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bconnect_candidates%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connect_candidates</dt>
<dd>the number of peers in this torrent's peer list that is a candidate to
be connected to. i.e. It has fewer connect attempts than the max fail
count, it is not a seed if we are a seed, it is not banned etc. If
this is 0, it means we don't know of any more peers that we can try.</dd>
</dl>
<a name="num_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_pieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_pieces</dt>
<dd>the number of pieces that has been downloaded. It is equivalent to:
<tt class="docutils literal"><span class="pre">std::accumulate(pieces-&gt;begin(),</span> <span class="pre">pieces-&gt;end())</span></tt>. So you don't have
to count yourself. This can be used to see if anything has updated
since last time if you want to keep a graph of the pieces up to date.</dd>
</dl>
<a name="distributed_full_copies"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdistributed_full_copies%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdistributed_full_copies%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>distributed_full_copies</dt>
<dd>the number of distributed copies of the torrent. Note that one copy
may be spread out among many peers. It tells how many copies there are
currently of the rarest piece(s) among the peers this client is
connected to.</dd>
</dl>
<a name="distributed_fraction"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdistributed_fraction%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdistributed_fraction%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>distributed_fraction</dt>
<dd><p class="first">tells the share of pieces that have more copies than the rarest
piece(s). Divide this number by 1000 to get the fraction.</p>
<p>For example, if <tt class="docutils literal">distributed_full_copies</tt> is 2 and
<tt class="docutils literal">distributed_fraction</tt> is 500, it means that the rarest pieces have
only 2 copies among the peers this torrent is connected to, and that
50% of all the pieces have more than two copies.</p>
<p class="last">If we are a seed, the piece picker is deallocated as an optimization,
and piece availability is no longer tracked. In this case the
distributed copies members are set to -1.</p>
</dd>
</dl>
<a name="distributed_copies"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bdistributed_copies%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bdistributed_copies%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>distributed_copies</dt>
<dd><p class="first">the number of distributed copies of the file. note that one copy may
be spread out among many peers. This is a floating point
representation of the distributed copies.</p>
<dl class="last docutils">
<dt>the integer part tells how many copies</dt>
<dd>there are of the rarest piece(s)</dd>
<dt>the fractional part tells the fraction of pieces that</dt>
<dd>have more copies than the rarest piece(s).</dd>
</dl>
</dd>
</dl>
<a name="block_size"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bblock_size%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bblock_size%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>block_size</dt>
<dd>the size of a block, in bytes. A block is a sub piece, it is the
number of bytes that each piece request asks for and the number of
bytes that each bit in the <tt class="docutils literal">partial_piece_info</tt>'s bitset represents,
see <a class="reference external" href="reference-Core.html#get_download_queue()">get_download_queue()</a>. This is typically 16 kB, but it may be
smaller, if the pieces are smaller.</dd>
</dl>
<a name="num_uploads"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_uploads%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_uploads%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_uploads</dt>
<dd>the number of unchoked peers in this torrent.</dd>
</dl>
<a name="num_connections"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bnum_connections%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bnum_connections%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_connections</dt>
<dd>the number of peer connections this torrent has, including half-open
connections that hasn't completed the bittorrent handshake yet. This
is always &gt;= <tt class="docutils literal">num_peers</tt>.</dd>
</dl>
<a name="uploads_limit"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Buploads_limit%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Buploads_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>uploads_limit</dt>
<dd>the set limit of upload slots (unchoked peers) for this torrent.</dd>
</dl>
<a name="connections_limit"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bconnections_limit%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bconnections_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connections_limit</dt>
<dd>the set limit of number of connections for this torrent.</dd>
</dl>
<a name="up_bandwidth_queue"></a>
<a name="down_bandwidth_queue"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bup_bandwidth_queue+down_bandwidth_queue%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bup_bandwidth_queue+down_bandwidth_queue%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>up_bandwidth_queue down_bandwidth_queue</dt>
<dd>the number of peers in this torrent that are waiting for more
bandwidth quota from the torrent rate limiter. This can determine if
the rate you get from this torrent is bound by the torrents limit or
not. If there is no limit set on this torrent, the peers might still
be waiting for bandwidth quota from the global limiter, but then they
are counted in the <tt class="docutils literal">session_status</tt> object.</dd>
</dl>
<a name="seed_rank"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bseed_rank%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bseed_rank%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>seed_rank</dt>
<dd>A rank of how important it is to seed the torrent, it is used to
determine which torrents to seed and which to queue. It is based on
the peer to seed ratio from the tracker scrape. For more information,
see <a class="reference external" href="manual-ref.html#queuing">queuing</a>. Higher value means more important to seed</dd>
</dl>
<a name="state"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bstate%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bstate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>state</dt>
<dd>the main state the torrent is in. See <a class="reference external" href="reference-Core.html#state_t">torrent_status::state_t</a>.</dd>
</dl>
<a name="need_save_resume"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bneed_save_resume%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bneed_save_resume%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>need_save_resume</dt>
<dd>true if this torrent has unsaved changes
to its download state and statistics since the last resume data
was saved.</dd>
</dl>
<a name="is_seeding"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bis_seeding%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bis_seeding%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>is_seeding</dt>
<dd>true if all pieces have been downloaded.</dd>
</dl>
<a name="is_finished"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bis_finished%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bis_finished%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>is_finished</dt>
<dd>true if all pieces that have a priority &gt; 0 are downloaded. There is
only a distinction between finished and seeding if some pieces or
files have been set to priority 0, i.e. are not downloaded.</dd>
</dl>
<a name="has_metadata"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bhas_metadata%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bhas_metadata%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>has_metadata</dt>
<dd>true if this torrent has metadata (either it was started from a
.torrent file or the metadata has been downloaded). The only scenario
where this can be false is when the torrent was started torrent-less
(i.e. with just an info-hash and tracker ip, a magnet link for
instance).</dd>
</dl>
<a name="has_incoming"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bhas_incoming%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bhas_incoming%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>has_incoming</dt>
<dd>true if there has ever been an incoming connection attempt to this
torrent.</dd>
</dl>
<a name="moving_storage"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bmoving_storage%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bmoving_storage%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>moving_storage</dt>
<dd>this is true if this torrent's storage is currently being moved from
one location to another. This may potentially be a long operation
if a large file ends up being copied from one drive to another.</dd>
</dl>
<a name="announcing_to_trackers"></a>
<a name="announcing_to_lsd"></a>
<a name="announcing_to_dht"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bannouncing_to_trackers+announcing_to_lsd+announcing_to_dht%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bannouncing_to_trackers+announcing_to_lsd+announcing_to_dht%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>announcing_to_trackers announcing_to_lsd announcing_to_dht</dt>
<dd>these are set to true if this torrent is allowed to announce to the
respective peer source. Whether they are true or false is determined by
the queue logic/auto manager. Torrents that are not auto managed will
always be allowed to announce to all peer sources.</dd>
</dl>
<a name="info_hash"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Binfo_hash%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Binfo_hash%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>info_hash</dt>
<dd>the info-hash for this torrent</dd>
</dl>
<a name="last_upload"></a>
<a name="last_download"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Blast_upload+last_download%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Blast_upload+last_download%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_upload last_download</dt>
<dd>the timestamps of the last time this torrent uploaded or downloaded
payload to any peer.</dd>
</dl>
<a name="active_duration"></a>
<a name="finished_duration"></a>
<a name="seeding_duration"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bactive_duration+finished_duration+seeding_duration%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bactive_duration+finished_duration+seeding_duration%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>active_duration finished_duration seeding_duration</dt>
<dd>these are cumulative counters of for how long the torrent has been in
different states. active means not paused and added to <a class="reference external" href="reference-Session.html#session">session</a>. Whether
it has found any peers or not is not relevant.
finished means all selected files/pieces were downloaded and available
to other peers (this is always a subset of active time).
seeding means all files/pieces were downloaded and available to
peers. Being available to peers does not imply there are other peers
asking for the payload.</dd>
</dl>
<a name="flags"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_status%3A%3A%5Bflags%5D&labels=documentation&body=Documentation+under+heading+%22torrent_status%3A%3A%5Bflags%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flags</dt>
<dd>reflects several of the torrent's flags. For more
information, see <tt class="docutils literal"><span class="pre">torrent_handle::flags()</span></tt>.</dd>
</dl>
<a name="announce_endpoint"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+announce_endpoint&labels=documentation&body=Documentation+under+heading+%22class+announce_endpoint%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="announce-endpoint">
<h2>announce_endpoint</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/announce_entry.hpp">libtorrent/announce_entry.hpp</a>&quot;</p>
<p>announces are sent to each tracker using every listen socket
this class holds information about one listen socket for one tracker</p>
<pre class="literal-block">
struct announce_endpoint
{
   void <strong>reset</strong> ();
   void <strong>failed</strong> (int backoff_ratio, seconds32 retry_interval = seconds32(0));
   bool <strong>can_announce</strong> (time_point now, bool is_seed, std::uint8_t fail_limit) const;
   bool <strong>is_working</strong> () const;

   std::string message;
   error_code last_error;
   tcp::endpoint local_endpoint;
   int <strong>scrape_incomplete</strong>  = -1;
   int <strong>scrape_complete</strong>  = -1;
   int <strong>scrape_downloaded</strong>  = -1;
   std::uint8_t fails : 7;
   bool updating : 1;
   bool start_sent : 1;
   bool complete_sent : 1;
   bool enabled : 1;
};
</pre>
<a name="reset()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Breset%28%29%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Breset%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="reset">
<h3>reset()</h3>
<pre class="literal-block">
void <strong>reset</strong> ();
</pre>
<p>reset announce counters and clears the started sent flag.
The <a class="reference external" href="reference-Core.html#announce_endpoint">announce_endpoint</a> will look like we've never talked to
the tracker.</p>
<a name="failed()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bfailed%28%29%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bfailed%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="failed">
<h3>failed()</h3>
<pre class="literal-block">
void <strong>failed</strong> (int backoff_ratio, seconds32 retry_interval = seconds32(0));
</pre>
<p>updates the failure counter and time-outs for re-trying.
This is called when the tracker announce fails.</p>
<a name="can_announce()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bcan_announce%28%29%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bcan_announce%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="can-announce">
<h3>can_announce()</h3>
<pre class="literal-block">
bool <strong>can_announce</strong> (time_point now, bool is_seed, std::uint8_t fail_limit) const;
</pre>
<p>returns true if we can announce to this tracker now.
The current time is passed in as <tt class="docutils literal">now</tt>. The <tt class="docutils literal">is_seed</tt>
argument is necessary because once we become a seed, we
need to announce right away, even if the re-announce timer
hasn't expired yet.</p>
<a name="is_working()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bis_working%28%29%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bis_working%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-working">
<h3>is_working()</h3>
<pre class="literal-block">
bool <strong>is_working</strong> () const;
</pre>
<p>returns true if the last time we tried to announce to this
tracker succeeded, or if we haven't tried yet.</p>
<a name="message"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bmessage%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bmessage%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>message</dt>
<dd>if this tracker has returned an error or warning message
that message is stored here</dd>
</dl>
<a name="last_error"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Blast_error%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Blast_error%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_error</dt>
<dd>if this tracker failed the last time it was contacted
this error code specifies what error occurred</dd>
</dl>
<a name="local_endpoint"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Blocal_endpoint%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Blocal_endpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_endpoint</dt>
<dd>the local endpoint of the listen interface associated with this endpoint</dd>
</dl>
<a name="scrape_incomplete"></a>
<a name="scrape_complete"></a>
<a name="scrape_downloaded"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bscrape_incomplete+scrape_complete+scrape_downloaded%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bscrape_incomplete+scrape_complete+scrape_downloaded%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>scrape_incomplete scrape_complete scrape_downloaded</dt>
<dd>if this tracker has returned scrape data, these fields are filled in
with valid numbers. Otherwise they are set to -1. <tt class="docutils literal">incomplete</tt> counts
the number of current downloaders. <tt class="docutils literal">complete</tt> counts the number of
current peers completed the download, or &quot;seeds&quot;. <tt class="docutils literal">downloaded</tt> is the
cumulative number of completed downloads.</dd>
</dl>
<a name="fails"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bfails%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bfails%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>fails</dt>
<dd>the number of times in a row we have failed to announce to this
tracker.</dd>
</dl>
<a name="updating"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bupdating%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bupdating%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>updating</dt>
<dd>true while we're waiting for a response from the tracker.</dd>
</dl>
<a name="start_sent"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bstart_sent%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bstart_sent%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>start_sent</dt>
<dd>set to true when we get a valid response from an announce
with event=started. If it is set, we won't send start in the subsequent
announces.</dd>
</dl>
<a name="complete_sent"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Bcomplete_sent%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Bcomplete_sent%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>complete_sent</dt>
<dd>set to true when we send a event=completed.</dd>
</dl>
<a name="enabled"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_endpoint%3A%3A%5Benabled%5D&labels=documentation&body=Documentation+under+heading+%22announce_endpoint%3A%3A%5Benabled%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>enabled</dt>
<dd>set to false to not announce from this endpoint</dd>
</dl>
<a name="announce_entry"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+announce_entry&labels=documentation&body=Documentation+under+heading+%22class+announce_entry%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="announce-entry">
<h2>announce_entry</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/announce_entry.hpp">libtorrent/announce_entry.hpp</a>&quot;</p>
<p>this class holds information about one bittorrent tracker, as it
relates to a specific torrent.</p>
<pre class="literal-block">
struct announce_entry
{
   explicit <strong>announce_entry</strong> (string_view u);
   <strong>announce_entry</strong> ();
   <strong>announce_entry</strong> (announce_entry const&amp;);
   announce_entry&amp; <strong>operator=</strong> (announce_entry const&amp;);
   <strong>~announce_entry</strong> ();
   void <strong>reset</strong> ();
   void <strong>trim</strong> ();

   enum tracker_source
   {
      source_torrent,
      source_client,
      source_magnet_link,
      source_tex,
   };

   std::string url;
   std::string trackerid;
   std::vector&lt;announce_endpoint&gt; endpoints;
   std::uint8_t <strong>tier</strong>  = 0;
   std::uint8_t <strong>fail_limit</strong>  = 0;
   std::uint8_t source:4;
   bool verified:1;
};
</pre>
<a name="operator=()"></a>
<a name="~announce_entry()"></a>
<a name="announce_entry()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Boperator%3D%28%29+~announce_entry%28%29+announce_entry%28%29%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Boperator%3D%28%29+~announce_entry%28%29+announce_entry%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator-announce-entry-announce-entry">
<h3>operator=() ~announce_entry() announce_entry()</h3>
<pre class="literal-block">
explicit <strong>announce_entry</strong> (string_view u);
<strong>announce_entry</strong> ();
<strong>announce_entry</strong> (announce_entry const&amp;);
announce_entry&amp; <strong>operator=</strong> (announce_entry const&amp;);
<strong>~announce_entry</strong> ();
</pre>
<p>constructs a tracker announce <a class="reference external" href="reference-Bencoding.html#entry">entry</a> with <tt class="docutils literal">u</tt> as the URL.</p>
<a name="reset()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Breset%28%29%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Breset%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="id32">
<h3>reset()</h3>
<pre class="literal-block">
void <strong>reset</strong> ();
</pre>
<p>reset announce counters and clears the started sent flag.
The <a class="reference external" href="reference-Core.html#announce_entry">announce_entry</a> will look like we've never talked to
the tracker.</p>
<a name="trim()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Btrim%28%29%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Btrim%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="trim">
<h3>trim()</h3>
<pre class="literal-block">
void <strong>trim</strong> ();
</pre>
<p>trims whitespace characters from the beginning of the URL.</p>
<a name="tracker_source"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+tracker_source&labels=documentation&body=Documentation+under+heading+%22enum+tracker_source%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-tracker-source">
<h3>enum tracker_source</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/announce_entry.hpp">libtorrent/announce_entry.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="7%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>source_torrent</td>
<td>1</td>
<td>the tracker was part of the .torrent file</td>
</tr>
<tr><td>source_client</td>
<td>2</td>
<td>the tracker was added programmatically via the <a class="reference external" href="reference-Core.html#add_tracker()">add_tracker()</a> function</td>
</tr>
<tr><td>source_magnet_link</td>
<td>4</td>
<td>the tracker was part of a magnet link</td>
</tr>
<tr><td>source_tex</td>
<td>8</td>
<td>the tracker was received from the swarm via tracker exchange</td>
</tr>
</tbody>
</table>
<a name="url"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Burl%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Burl%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>url</dt>
<dd>tracker URL as it appeared in the torrent file</dd>
</dl>
<a name="trackerid"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Btrackerid%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Btrackerid%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>trackerid</dt>
<dd>the current <tt class="docutils literal">&amp;trackerid=</tt> argument passed to the tracker.
this is optional and is normally empty (in which case no
trackerid is sent).</dd>
</dl>
<a name="endpoints"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Bendpoints%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Bendpoints%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endpoints</dt>
<dd>each local listen socket (endpoint) will announce to the tracker. This
list contains state per endpoint.</dd>
</dl>
<a name="tier"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Btier%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Btier%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>tier</dt>
<dd>the tier this tracker belongs to</dd>
</dl>
<a name="fail_limit"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Bfail_limit%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Bfail_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>fail_limit</dt>
<dd>the max number of failures to announce to this tracker in
a row, before this tracker is not used anymore. 0 means unlimited</dd>
</dl>
<a name="source"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Bsource%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Bsource%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>source</dt>
<dd>a bitmask specifying which sources we got this tracker from.</dd>
</dl>
<a name="verified"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:announce_entry%3A%3A%5Bverified%5D&labels=documentation&body=Documentation+under+heading+%22announce_entry%3A%3A%5Bverified%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>verified</dt>
<dd>set to true the first time we receive a valid response
from this tracker.</dd>
</dl>
<a name="open_file_state"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+open_file_state&labels=documentation&body=Documentation+under+heading+%22class+open_file_state%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="open-file-state">
<h2>open_file_state</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/disk_interface.hpp">libtorrent/disk_interface.hpp</a>&quot;</p>
<p>this contains information about a file that's currently open by the
libtorrent disk I/O subsystem. It's associated with a single torrent.</p>
<pre class="literal-block">
struct open_file_state
{
   file_index_t file_index;
   file_open_mode_t open_mode;
   time_point last_use;
};
</pre>
<a name="file_index"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:open_file_state%3A%3A%5Bfile_index%5D&labels=documentation&body=Documentation+under+heading+%22open_file_state%3A%3A%5Bfile_index%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>file_index</dt>
<dd>the index of the file this <a class="reference external" href="reference-Bencoding.html#entry">entry</a> refers to into the <tt class="docutils literal">file_storage</tt>
file list of this torrent. This starts indexing at 0.</dd>
</dl>
<a name="open_mode"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:open_file_state%3A%3A%5Bopen_mode%5D&labels=documentation&body=Documentation+under+heading+%22open_file_state%3A%3A%5Bopen_mode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>open_mode</dt>
<dd><p class="first"><tt class="docutils literal">open_mode</tt> is a bitmask of the file flags this file is currently
opened with. These are the flags used in the <tt class="docutils literal"><span class="pre">file::open()</span></tt> function.
For possible flags, see <a class="reference external" href="reference-Core.html#file_open_mode_t">file_open_mode_t</a>.</p>
<p class="last">Note that the read/write mode is not a bitmask. The two least significant bits are used
to represent the read/write mode. Those bits can be masked out using the <tt class="docutils literal">rw_mask</tt> constant.</p>
</dd>
</dl>
<a name="last_use"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:open_file_state%3A%3A%5Blast_use%5D&labels=documentation&body=Documentation+under+heading+%22open_file_state%3A%3A%5Blast_use%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_use</dt>
<dd>a (high precision) timestamp of when the file was last used.</dd>
</dl>
<a name="peer_class_type_filter"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_class_type_filter&labels=documentation&body=Documentation+under+heading+%22class+peer_class_type_filter%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="peer-class-type-filter">
<h2>peer_class_type_filter</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_class_type_filter.hpp">libtorrent/peer_class_type_filter.hpp</a>&quot;</p>
<p><tt class="docutils literal">peer_class_type_filter</tt> is a simple container for rules for adding and subtracting
peer-classes from peers. It is applied <em>after</em> the peer class filter is applied (which
is based on the peer's IP address).</p>
<pre class="literal-block">
struct peer_class_type_filter
{
   void <strong>remove</strong> (socket_type_t const st, peer_class_t const peer_class);
   void <strong>add</strong> (socket_type_t const st, peer_class_t const peer_class);
   void <strong>allow</strong> (socket_type_t const st, peer_class_t const peer_class);
   void <strong>disallow</strong> (socket_type_t const st, peer_class_t const peer_class);
   std::uint32_t <strong>apply</strong> (socket_type_t const st, std::uint32_t peer_class_mask);

   enum socket_type_t
   {
      tcp_socket,
      utp_socket,
      ssl_tcp_socket,
      ssl_utp_socket,
      i2p_socket,
      num_socket_types,
   };
};
</pre>
<a name="add()"></a>
<a name="remove()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_type_filter%3A%3A%5Badd%28%29+remove%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_type_filter%3A%3A%5Badd%28%29+remove%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="add-remove">
<h3>add() remove()</h3>
<pre class="literal-block">
void <strong>remove</strong> (socket_type_t const st, peer_class_t const peer_class);
void <strong>add</strong> (socket_type_t const st, peer_class_t const peer_class);
</pre>
<p><tt class="docutils literal">add()</tt> and <tt class="docutils literal">remove()</tt> adds and removes a peer class to be added
to new peers based on socket type.</p>
<a name="allow()"></a>
<a name="disallow()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_type_filter%3A%3A%5Ballow%28%29+disallow%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_type_filter%3A%3A%5Ballow%28%29+disallow%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="allow-disallow">
<h3>allow() disallow()</h3>
<pre class="literal-block">
void <strong>allow</strong> (socket_type_t const st, peer_class_t const peer_class);
void <strong>disallow</strong> (socket_type_t const st, peer_class_t const peer_class);
</pre>
<p><tt class="docutils literal">disallow()</tt> and <tt class="docutils literal">allow()</tt> adds and removes a peer class to be
removed from new peers based on socket type.</p>
<p>The <tt class="docutils literal">peer_class</tt> argument cannot be greater than 31. The bitmasks representing
peer classes in the <tt class="docutils literal">peer_class_type_filter</tt> are 32 bits.</p>
<a name="apply()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_class_type_filter%3A%3A%5Bapply%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_class_type_filter%3A%3A%5Bapply%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="apply">
<h3>apply()</h3>
<pre class="literal-block">
std::uint32_t <strong>apply</strong> (socket_type_t const st, std::uint32_t peer_class_mask);
</pre>
<p>takes a bitmask of peer classes and returns a new bitmask of
peer classes after the rules have been applied, based on the socket type argument
(<tt class="docutils literal">st</tt>).</p>
<a name="socket_type_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+socket_type_t&labels=documentation&body=Documentation+under+heading+%22enum+socket_type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-socket-type-t">
<h3>enum socket_type_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_class_type_filter.hpp">libtorrent/peer_class_type_filter.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="9%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>tcp_socket</td>
<td>0</td>
<td>these match the socket types from socket_type.hpp
shifted one down</td>
</tr>
<tr><td>utp_socket</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>ssl_tcp_socket</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
<tr><td>ssl_utp_socket</td>
<td>3</td>
<td>&nbsp;</td>
</tr>
<tr><td>i2p_socket</td>
<td>4</td>
<td>&nbsp;</td>
</tr>
<tr><td>num_socket_types</td>
<td>5</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="block_info"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+block_info&labels=documentation&body=Documentation+under+heading+%22class+block_info%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="block-info">
<h2>block_info</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<p>holds the state of a block in a piece. Who we requested
it from and how far along we are at downloading it.</p>
<pre class="literal-block">
struct block_info
{
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> <strong>peer</strong> () const;
   void <strong>set_peer</strong> (tcp::endpoint const&amp; ep);

   enum block_state_t
   {
      none,
      requested,
      writing,
      finished,
   };

   unsigned bytes_progress:15;
   unsigned block_size:15;
   unsigned state:2;
   unsigned num_peers:14;
};
</pre>
<a name="set_peer()"></a>
<a name="peer()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bset_peer%28%29+peer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bset_peer%28%29+peer%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="set-peer-peer">
<h3>set_peer() peer()</h3>
<pre class="literal-block">
<a class="reference external" href="tcp::endpoint">tcp::endpoint</a> <strong>peer</strong> () const;
void <strong>set_peer</strong> (tcp::endpoint const&amp; ep);
</pre>
<p>The peer is the ip address of the peer this block was downloaded from.</p>
<a name="block_state_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+block_state_t&labels=documentation&body=Documentation+under+heading+%22enum+block_state_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-block-state-t">
<h3>enum block_state_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="13%" />
<col width="8%" />
<col width="79%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>This block has not been downloaded or requested form any peer.</td>
</tr>
<tr><td>requested</td>
<td>1</td>
<td>The block has been requested, but not completely downloaded yet.</td>
</tr>
<tr><td>writing</td>
<td>2</td>
<td>The block has been downloaded and is currently queued for being
written to disk.</td>
</tr>
<tr><td>finished</td>
<td>3</td>
<td>The block has been written to disk.</td>
</tr>
</tbody>
</table>
<a name="bytes_progress"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bbytes_progress%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bbytes_progress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bytes_progress</dt>
<dd>the number of bytes that have been received for this block</dd>
</dl>
<a name="block_size"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bblock_size%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bblock_size%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>block_size</dt>
<dd>the total number of bytes in this block.</dd>
</dl>
<a name="state"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bstate%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bstate%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>state</dt>
<dd>the state this block is in (see <a class="reference external" href="reference-Core.html#block_state_t">block_state_t</a>)</dd>
</dl>
<a name="num_peers"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:block_info%3A%3A%5Bnum_peers%5D&labels=documentation&body=Documentation+under+heading+%22block_info%3A%3A%5Bnum_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_peers</dt>
<dd>the number of peers that is currently requesting this block. Typically
this is 0 or 1, but at the end of the torrent blocks may be requested
by more peers in parallel to speed things up.</dd>
</dl>
<a name="partial_piece_info"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+partial_piece_info&labels=documentation&body=Documentation+under+heading+%22class+partial_piece_info%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="partial-piece-info">
<h2>partial_piece_info</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<p>This class holds information about pieces that have outstanding requests
or outstanding writes</p>
<pre class="literal-block">
struct partial_piece_info
{
   piece_index_t piece_index;
   int blocks_in_piece;
   int finished;
   int writing;
   int requested;
   block_info* blocks;
};
</pre>
<a name="piece_index"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bpiece_index%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bpiece_index%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece_index</dt>
<dd>the index of the piece in question. <tt class="docutils literal">blocks_in_piece</tt> is the number
of blocks in this particular piece. This number will be the same for
most pieces, but
the last piece may have fewer blocks than the standard pieces.</dd>
</dl>
<a name="blocks_in_piece"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bblocks_in_piece%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bblocks_in_piece%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>blocks_in_piece</dt>
<dd>the number of blocks in this piece</dd>
</dl>
<a name="finished"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bfinished%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bfinished%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>finished</dt>
<dd>the number of blocks that are in the finished state</dd>
</dl>
<a name="writing"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bwriting%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bwriting%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>writing</dt>
<dd>the number of blocks that are in the writing state</dd>
</dl>
<a name="requested"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Brequested%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Brequested%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>requested</dt>
<dd>the number of blocks that are in the requested state</dd>
</dl>
<a name="blocks"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:partial_piece_info%3A%3A%5Bblocks%5D&labels=documentation&body=Documentation+under+heading+%22partial_piece_info%3A%3A%5Bblocks%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>blocks</dt>
<dd><p class="first">this is an array of <tt class="docutils literal">blocks_in_piece</tt> number of
items. One for each block in the piece.</p>
<div class="admonition warning last">
<p class="first admonition-title">Warning</p>
<p class="last">This is a pointer that points to an array
that's owned by the <a class="reference external" href="reference-Session.html#session">session</a> object. The next time
<a class="reference external" href="reference-Core.html#get_download_queue()">get_download_queue()</a> is called, it will be invalidated.</p>
</div>
</dd>
</dl>
<a name="torrent_handle"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_handle&labels=documentation&body=Documentation+under+heading+%22class+torrent_handle%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-handle">
<h2>torrent_handle</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<p>You will usually have to store your torrent handles somewhere, since it's
the object through which you retrieve information about the torrent and
aborts the torrent.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Any member function that returns a value or fills in a value has to be
made synchronously. This means it has to wait for the main thread to
complete the query before it can return. This might potentially be
expensive if done from within a GUI thread that needs to stay
responsive. Try to avoid querying for information you don't need, and
try to do it in as few calls as possible. You can get most of the
interesting information about a torrent from the
<a class="reference external" href="reference-Core.html#status()">torrent_handle::status()</a> call.</p>
</div>
<p>The default constructor will initialize the handle to an invalid state.
Which means you cannot perform any operation on it, unless you first
assign it a valid handle. If you try to perform any operation on an
uninitialized handle, it will throw <tt class="docutils literal">invalid_handle</tt>.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">All operations on a <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a> may throw system_error
exception, in case the handle is no longer referring to a torrent.
There is one exception <a class="reference external" href="reference-Storage.html#is_valid()">is_valid()</a> will never throw. Since the torrents
are processed by a background thread, there is no guarantee that a
handle will remain valid between two calls.</p>
</div>
<pre class="literal-block">
struct torrent_handle
{
   <strong>torrent_handle</strong> () noexcept = default;
   void <strong>add_piece</strong> (piece_index_t piece, char const* data, add_piece_flags_t flags = {}) const;
   void <strong>read_piece</strong> (piece_index_t piece) const;
   bool <strong>have_piece</strong> (piece_index_t piece) const;
   void <strong>get_peer_info</strong> (std::vector&lt;peer_info&gt;&amp; v) const;
   torrent_status <strong>status</strong> (status_flags_t flags = status_flags_t::all()) const;
   void <strong>get_download_queue</strong> (std::vector&lt;partial_piece_info&gt;&amp; queue) const;
   void <strong>set_piece_deadline</strong> (piece_index_t index, int deadline, deadline_flags_t flags = {}) const;
   void <strong>clear_piece_deadlines</strong> () const;
   void <strong>reset_piece_deadline</strong> (piece_index_t index) const;
   void <strong>file_progress</strong> (std::vector&lt;std::int64_t&gt;&amp; progress, int flags = 0) const;
   std::vector&lt;open_file_state&gt; <strong>file_status</strong> () const;
   void <strong>clear_error</strong> () const;
   void <strong>replace_trackers</strong> (std::vector&lt;announce_entry&gt; const&amp;) const;
   void <strong>add_tracker</strong> (announce_entry const&amp;) const;
   std::vector&lt;announce_entry&gt; <strong>trackers</strong> () const;
   std::set&lt;std::string&gt; <strong>url_seeds</strong> () const;
   void <strong>add_url_seed</strong> (std::string const&amp; url) const;
   void <strong>remove_url_seed</strong> (std::string const&amp; url) const;
   void <strong>remove_http_seed</strong> (std::string const&amp; url) const;
   void <strong>add_http_seed</strong> (std::string const&amp; url) const;
   std::set&lt;std::string&gt; <strong>http_seeds</strong> () const;
   void <strong>add_extension</strong> (
      std::function&lt;std::shared_ptr&lt;torrent_plugin&gt;(torrent_handle const&amp;, void*)&gt; const&amp; ext
      , void* userdata = nullptr);
   bool <strong>set_metadata</strong> (span&lt;char const&gt; metadata) const;
   bool <strong>is_valid</strong> () const;
   void <strong>resume</strong> () const;
   void <strong>pause</strong> (pause_flags_t flags = {}) const;
   torrent_flags_t <strong>flags</strong> () const;
   void <strong>unset_flags</strong> (torrent_flags_t flags) const;
   void <strong>set_flags</strong> (torrent_flags_t flags) const;
   void <strong>set_flags</strong> (torrent_flags_t flags, torrent_flags_t mask) const;
   void <strong>flush_cache</strong> () const;
   void <strong>force_recheck</strong> () const;
   void <strong>save_resume_data</strong> (resume_data_flags_t flags = {}) const;
   bool <strong>need_save_resume_data</strong> () const;
   queue_position_t <strong>queue_position</strong> () const;
   void <strong>queue_position_down</strong> () const;
   void <strong>queue_position_up</strong> () const;
   void <strong>queue_position_bottom</strong> () const;
   void <strong>queue_position_top</strong> () const;
   void <strong>queue_position_set</strong> (queue_position_t p) const;
   void <strong>set_ssl_certificate</strong> (std::string const&amp; certificate
      , std::string const&amp; private_key
      , std::string const&amp; dh_params
      , std::string const&amp; passphrase = &quot;&quot;);
   void <strong>set_ssl_certificate_buffer</strong> (std::string const&amp; certificate
      , std::string const&amp; private_key
      , std::string const&amp; dh_params);
   storage_interface* <strong>get_storage_impl</strong> () const;
   std::shared_ptr&lt;const torrent_info&gt; <strong>torrent_file</strong> () const;
   void <strong>piece_availability</strong> (std::vector&lt;int&gt;&amp; avail) const;
   void <strong>prioritize_pieces</strong> (std::vector&lt;download_priority_t&gt; const&amp; pieces) const;
   download_priority_t <strong>piece_priority</strong> (piece_index_t index) const;
   void <strong>prioritize_pieces</strong> (std::vector&lt;std::pair&lt;piece_index_t, download_priority_t&gt;&gt; const&amp; pieces) const;
   void <strong>piece_priority</strong> (piece_index_t index, download_priority_t priority) const;
   std::vector&lt;download_priority_t&gt; <strong>get_piece_priorities</strong> () const;
   void <strong>prioritize_files</strong> (std::vector&lt;download_priority_t&gt; const&amp; files) const;
   void <strong>file_priority</strong> (file_index_t index, download_priority_t priority) const;
   std::vector&lt;download_priority_t&gt; <strong>get_file_priorities</strong> () const;
   download_priority_t <strong>file_priority</strong> (file_index_t index) const;
   void <strong>force_reannounce</strong> (int seconds = 0, int tracker_index = -1, reannounce_flags_t = {}) const;
   void <strong>force_dht_announce</strong> () const;
   void <strong>scrape_tracker</strong> (int idx = -1) const;
   int <strong>upload_limit</strong> () const;
   void <strong>set_upload_limit</strong> (int limit) const;
   int <strong>download_limit</strong> () const;
   void <strong>set_download_limit</strong> (int limit) const;
   void <strong>connect_peer</strong> (tcp::endpoint const&amp; adr, peer_source_flags_t source = {}
      , pex_flags_t flags = pex_encryption | pex_utp | pex_holepunch) const;
   void <strong>clear_peers</strong> ();
   void <strong>set_max_uploads</strong> (int max_uploads) const;
   int <strong>max_uploads</strong> () const;
   int <strong>max_connections</strong> () const;
   void <strong>set_max_connections</strong> (int max_connections) const;
   void <strong>move_storage</strong> (std::string const&amp; save_path
      , move_flags_t flags = move_flags_t::always_replace_files
      ) const;
   void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_name) const;
   sha1_hash <strong>info_hash</strong> () const;
   bool <strong>operator!=</strong> (const torrent_handle&amp; h) const;
   bool <strong>operator&lt;</strong> (const torrent_handle&amp; h) const;
   bool <strong>operator==</strong> (const torrent_handle&amp; h) const;
   std::uint32_t <strong>id</strong> () const;
   std::shared_ptr&lt;torrent&gt; <strong>native_handle</strong> () const;

   enum file_progress_flags_t
   {
      piece_granularity,
   };

   static constexpr add_piece_flags_t <strong>overwrite_existing</strong>  = 0_bit;
   static constexpr status_flags_t <strong>query_distributed_copies</strong>  = 0_bit;
   static constexpr status_flags_t <strong>query_accurate_download_counters</strong>  = 1_bit;
   static constexpr status_flags_t <strong>query_last_seen_complete</strong>  = 2_bit;
   static constexpr status_flags_t <strong>query_pieces</strong>  = 3_bit;
   static constexpr status_flags_t <strong>query_verified_pieces</strong>  = 4_bit;
   static constexpr status_flags_t <strong>query_torrent_file</strong>  = 5_bit;
   static constexpr status_flags_t <strong>query_name</strong>  = 6_bit;
   static constexpr status_flags_t <strong>query_save_path</strong>  = 7_bit;
   static constexpr deadline_flags_t <strong>alert_when_available</strong>  = 0_bit;
   static constexpr pause_flags_t <strong>graceful_pause</strong>  = 0_bit;
   static constexpr pause_flags_t <strong>clear_disk_cache</strong>  = 1_bit;
   static constexpr resume_data_flags_t <strong>flush_disk_cache</strong>  = 0_bit;
   static constexpr resume_data_flags_t <strong>save_info_dict</strong>  = 1_bit;
   static constexpr resume_data_flags_t <strong>only_if_modified</strong>  = 2_bit;
   static constexpr reannounce_flags_t <strong>ignore_min_interval</strong>  = 0_bit;
};
</pre>
<a name="torrent_handle()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Btorrent_handle%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Btorrent_handle%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="id51">
<h3>torrent_handle()</h3>
<pre class="literal-block">
<strong>torrent_handle</strong> () noexcept = default;
</pre>
<p>constructs a torrent handle that does not refer to a torrent.
i.e. <a class="reference external" href="reference-Storage.html#is_valid()">is_valid()</a> will return false.</p>
<a name="add_piece()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Badd_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Badd_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-piece">
<h3>add_piece()</h3>
<pre class="literal-block">
void <strong>add_piece</strong> (piece_index_t piece, char const* data, add_piece_flags_t flags = {}) const;
</pre>
<p>This function will write <tt class="docutils literal">data</tt> to the storage as piece <tt class="docutils literal">piece</tt>,
as if it had been downloaded from a peer. <tt class="docutils literal">data</tt> is expected to
point to a buffer of as many bytes as the size of the specified piece.
The data in the buffer is copied and passed on to the disk IO thread
to be written at a later point.</p>
<p>By default, data that's already been downloaded is not overwritten by
this buffer. If you trust this data to be correct (and pass the piece
hash check) you may pass the overwrite_existing flag. This will
instruct libtorrent to overwrite any data that may already have been
downloaded with this data.</p>
<p>Since the data is written asynchronously, you may know that is passed
or failed the hash check by waiting for <a class="reference external" href="reference-Alerts.html#piece_finished_alert">piece_finished_alert</a> or
<a class="reference external" href="reference-Alerts.html#hash_failed_alert">hash_failed_alert</a>.</p>
<p>Adding pieces while the torrent is being checked (i.e. in
<a class="reference external" href="reference-Core.html#checking_files">torrent_status::checking_files</a> state) is not supported.</p>
<a name="read_piece()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bread_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bread_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="read-piece">
<h3>read_piece()</h3>
<pre class="literal-block">
void <strong>read_piece</strong> (piece_index_t piece) const;
</pre>
<p>This function starts an asynchronous read operation of the specified
piece from this torrent. You must have completed the download of the
specified piece before calling this function.</p>
<p>When the read operation is completed, it is passed back through an
<a class="reference external" href="reference-Alerts.html#alert">alert</a>, <a class="reference external" href="reference-Alerts.html#read_piece_alert">read_piece_alert</a>. Since this <a class="reference external" href="reference-Alerts.html#alert">alert</a> is a response to an explicit
call, it will always be posted, regardless of the <a class="reference external" href="reference-Alerts.html#alert">alert</a> mask.</p>
<p>Note that if you read multiple pieces, the read operations are not
guaranteed to finish in the same order as you initiated them.</p>
<a name="have_piece()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bhave_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bhave_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="have-piece">
<h3>have_piece()</h3>
<pre class="literal-block">
bool <strong>have_piece</strong> (piece_index_t piece) const;
</pre>
<p>Returns true if this piece has been completely downloaded and written
to disk, and false otherwise.</p>
<a name="get_peer_info()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bget_peer_info%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bget_peer_info%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-peer-info">
<h3>get_peer_info()</h3>
<pre class="literal-block">
void <strong>get_peer_info</strong> (std::vector&lt;peer_info&gt;&amp; v) const;
</pre>
<p>takes a reference to a vector that will be cleared and filled with one
<a class="reference external" href="reference-Bencoding.html#entry">entry</a> for each peer connected to this torrent, given the handle is
valid. If the <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a> is invalid, it will throw
system_error exception. Each <a class="reference external" href="reference-Bencoding.html#entry">entry</a> in the vector contains
information about that particular peer. See <a class="reference external" href="reference-Core.html#peer_info">peer_info</a>.</p>
<a name="status()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bstatus%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bstatus%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="status">
<h3>status()</h3>
<pre class="literal-block">
torrent_status <strong>status</strong> (status_flags_t flags = status_flags_t::all()) const;
</pre>
<p><tt class="docutils literal">status()</tt> will return a structure with information about the status
of this torrent. If the <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a> is invalid, it will throw
system_error exception. See <a class="reference external" href="reference-Core.html#torrent_status">torrent_status</a>. The <tt class="docutils literal">flags</tt>
argument filters what information is returned in the <a class="reference external" href="reference-Core.html#torrent_status">torrent_status</a>.
Some information in there is relatively expensive to calculate, and if
you're not interested in it (and see performance issues), you can
filter them out.</p>
<p>By default everything is included. The flags you can use to decide
what to <em>include</em> are defined in this class.</p>
<a name="get_download_queue()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bget_download_queue%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bget_download_queue%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-download-queue">
<h3>get_download_queue()</h3>
<pre class="literal-block">
void <strong>get_download_queue</strong> (std::vector&lt;partial_piece_info&gt;&amp; queue) const;
</pre>
<p><tt class="docutils literal">get_download_queue()</tt> takes a non-const reference to a vector which
it will fill with information about pieces that are partially
downloaded or not downloaded at all but partially requested. See
<a class="reference external" href="reference-Core.html#partial_piece_info">partial_piece_info</a> for the fields in the returned vector.</p>
<a name="set_piece_deadline()"></a>
<a name="clear_piece_deadlines()"></a>
<a name="reset_piece_deadline()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_piece_deadline%28%29+clear_piece_deadlines%28%29+reset_piece_deadline%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_piece_deadline%28%29+clear_piece_deadlines%28%29+reset_piece_deadline%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-piece-deadline-clear-piece-deadlines-reset-piece-deadline">
<h3>set_piece_deadline() clear_piece_deadlines() reset_piece_deadline()</h3>
<pre class="literal-block">
void <strong>set_piece_deadline</strong> (piece_index_t index, int deadline, deadline_flags_t flags = {}) const;
void <strong>clear_piece_deadlines</strong> () const;
void <strong>reset_piece_deadline</strong> (piece_index_t index) const;
</pre>
<p>This function sets or resets the deadline associated with a specific
piece index (<tt class="docutils literal">index</tt>). libtorrent will attempt to download this
entire piece before the deadline expires. This is not necessarily
possible, but pieces with a more recent deadline will always be
prioritized over pieces with a deadline further ahead in time. The
deadline (and flags) of a piece can be changed by calling this
function again.</p>
<p>If the piece is already downloaded when this call is made, nothing
happens, unless the alert_when_available flag is set, in which case it
will have the same effect as calling <a class="reference external" href="reference-Core.html#read_piece()">read_piece()</a> for <tt class="docutils literal">index</tt>.</p>
<p><tt class="docutils literal">deadline</tt> is the number of milliseconds until this piece should be
completed.</p>
<p><tt class="docutils literal">reset_piece_deadline</tt> removes the deadline from the piece. If it
hasn't already been downloaded, it will no longer be considered a
priority.</p>
<p><tt class="docutils literal">clear_piece_deadlines()</tt> removes deadlines on all pieces in
the torrent. As if <a class="reference external" href="reference-Core.html#reset_piece_deadline()">reset_piece_deadline()</a> was called on all pieces.</p>
<a name="file_progress()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bfile_progress%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bfile_progress%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-progress">
<h3>file_progress()</h3>
<pre class="literal-block">
void <strong>file_progress</strong> (std::vector&lt;std::int64_t&gt;&amp; progress, int flags = 0) const;
</pre>
<p>This function fills in the supplied vector with the number of
bytes downloaded of each file in this torrent. The progress values are
ordered the same as the files in the <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a>. This operation is
not very cheap. Its complexity is <em>O(n + mj)</em>. Where <em>n</em> is the number
of files, <em>m</em> is the number of downloading pieces and <em>j</em> is the
number of blocks in a piece.</p>
<p>The <tt class="docutils literal">flags</tt> parameter can be used to specify the granularity of the
file progress. If left at the default value of 0, the progress will be
as accurate as possible, but also more expensive to calculate. If
<tt class="docutils literal"><span class="pre">torrent_handle::piece_granularity</span></tt> is specified, the progress will
be specified in piece granularity. i.e. only pieces that have been
fully downloaded and passed the hash check count. When specifying
piece granularity, the operation is a lot cheaper, since libtorrent
already keeps track of this internally and no calculation is required.</p>
<a name="file_status()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bfile_status%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bfile_status%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-status">
<h3>file_status()</h3>
<pre class="literal-block">
std::vector&lt;open_file_state&gt; <strong>file_status</strong> () const;
</pre>
<p>This function returns a vector with status about files
that are open for this torrent. Any file that is not open
will not be reported in the vector, i.e. it's possible that
the vector is empty when returning, if none of the files in the
torrent are currently open.</p>
<p>See <a class="reference external" href="reference-Core.html#open_file_state">open_file_state</a></p>
<a name="clear_error()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bclear_error%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bclear_error%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear-error">
<h3>clear_error()</h3>
<pre class="literal-block">
void <strong>clear_error</strong> () const;
</pre>
<p>If the torrent is in an error state (i.e. <tt class="docutils literal"><span class="pre">torrent_status::error</span></tt> is
non-empty), this will clear the error and start the torrent again.</p>
<a name="replace_trackers()"></a>
<a name="add_tracker()"></a>
<a name="trackers()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Breplace_trackers%28%29+add_tracker%28%29+trackers%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Breplace_trackers%28%29+add_tracker%28%29+trackers%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="replace-trackers-add-tracker-trackers">
<h3>replace_trackers() add_tracker() trackers()</h3>
<pre class="literal-block">
void <strong>replace_trackers</strong> (std::vector&lt;announce_entry&gt; const&amp;) const;
void <strong>add_tracker</strong> (announce_entry const&amp;) const;
std::vector&lt;announce_entry&gt; <strong>trackers</strong> () const;
</pre>
<p><tt class="docutils literal">trackers()</tt> will return the list of trackers for this torrent. The
announce <a class="reference external" href="reference-Bencoding.html#entry">entry</a> contains both a string <tt class="docutils literal">url</tt> which specify the
announce url for the tracker as well as an <a class="reference external" href="reference-Alerts.html#int">int</a> <tt class="docutils literal">tier</tt>, which is
specifies the order in which this tracker is tried. If you want
libtorrent to use another list of trackers for this torrent, you can
use <tt class="docutils literal">replace_trackers()</tt> which takes a list of the same form as the
one returned from <tt class="docutils literal">trackers()</tt> and will replace it. If you want an
immediate effect, you have to call <a class="reference external" href="reference-Core.html#force_reannounce()">force_reannounce()</a>. See
<a class="reference external" href="reference-Core.html#announce_entry">announce_entry</a>.</p>
<p><tt class="docutils literal">add_tracker()</tt> will look if the specified tracker is already in the
set. If it is, it doesn't do anything. If it's not in the current set
of trackers, it will insert it in the tier specified in the
<a class="reference external" href="reference-Core.html#announce_entry">announce_entry</a>.</p>
<p>The updated set of trackers will be saved in the resume data, and when
a torrent is started with resume data, the trackers from the resume
data will replace the original ones.</p>
<a name="remove_url_seed()"></a>
<a name="url_seeds()"></a>
<a name="add_url_seed()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bremove_url_seed%28%29+url_seeds%28%29+add_url_seed%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bremove_url_seed%28%29+url_seeds%28%29+add_url_seed%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="remove-url-seed-url-seeds-add-url-seed">
<h3>remove_url_seed() url_seeds() add_url_seed()</h3>
<pre class="literal-block">
std::set&lt;std::string&gt; <strong>url_seeds</strong> () const;
void <strong>add_url_seed</strong> (std::string const&amp; url) const;
void <strong>remove_url_seed</strong> (std::string const&amp; url) const;
</pre>
<p><tt class="docutils literal">add_url_seed()</tt> adds another url to the torrent's list of url
seeds. If the given url already exists in that list, the call has no
effect. The torrent will connect to the server and try to download
pieces from it, unless it's paused, queued, checking or seeding.
<tt class="docutils literal">remove_url_seed()</tt> removes the given url if it exists already.
<tt class="docutils literal">url_seeds()</tt> return a set of the url seeds currently in this
torrent. Note that URLs that fails may be removed automatically from
the list.</p>
<p>See <a class="reference external" href="manual-ref.html#http-seeding">http seeding</a> for more information.</p>
<a name="add_http_seed()"></a>
<a name="http_seeds()"></a>
<a name="remove_http_seed()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Badd_http_seed%28%29+http_seeds%28%29+remove_http_seed%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Badd_http_seed%28%29+http_seeds%28%29+remove_http_seed%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-http-seed-http-seeds-remove-http-seed">
<h3>add_http_seed() http_seeds() remove_http_seed()</h3>
<pre class="literal-block">
void <strong>remove_http_seed</strong> (std::string const&amp; url) const;
void <strong>add_http_seed</strong> (std::string const&amp; url) const;
std::set&lt;std::string&gt; <strong>http_seeds</strong> () const;
</pre>
<p>These functions are identical as the <tt class="docutils literal">*_url_seed()</tt> variants, but
they operate on <a class="reference external" href="https://www.bittorrent.org/beps/bep_0017.html">BEP 17</a> web seeds instead of <a class="reference external" href="https://www.bittorrent.org/beps/bep_0019.html">BEP 19</a>.</p>
<p>See <a class="reference external" href="manual-ref.html#http-seeding">http seeding</a> for more information.</p>
<a name="add_extension()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Badd_extension%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Badd_extension%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-extension">
<h3>add_extension()</h3>
<pre class="literal-block">
void <strong>add_extension</strong> (
      std::function&lt;std::shared_ptr&lt;torrent_plugin&gt;(torrent_handle const&amp;, void*)&gt; const&amp; ext
      , void* userdata = nullptr);
</pre>
<p>add the specified extension to this torrent. The <tt class="docutils literal">ext</tt> argument is
a function that will be called from within libtorrent's context
passing in the internal torrent object and the specified userdata
pointer. The function is expected to return a shared pointer to
a <a class="reference external" href="reference-Plugins.html#torrent_plugin">torrent_plugin</a> instance.</p>
<a name="set_metadata()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_metadata%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_metadata%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-metadata">
<h3>set_metadata()</h3>
<pre class="literal-block">
bool <strong>set_metadata</strong> (span&lt;char const&gt; metadata) const;
</pre>
<p><tt class="docutils literal">set_metadata</tt> expects the <em>info</em> section of metadata. i.e. The
buffer passed in will be hashed and verified against the info-hash. If
it fails, a <tt class="docutils literal">metadata_failed_alert</tt> will be generated. If it passes,
a <tt class="docutils literal">metadata_received_alert</tt> is generated. The function returns true
if the metadata is successfully set on the torrent, and false
otherwise. If the torrent already has metadata, this function will not
affect the torrent, and false will be returned.</p>
<a name="is_valid()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bis_valid%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bis_valid%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-valid">
<h3>is_valid()</h3>
<pre class="literal-block">
bool <strong>is_valid</strong> () const;
</pre>
<p>Returns true if this handle refers to a valid torrent and false if it
hasn't been initialized or if the torrent it refers to has been
aborted. Note that a handle may become invalid after it has been added
to the <a class="reference external" href="reference-Session.html#session">session</a>. Usually this is because the storage for the torrent is
somehow invalid or if the filenames are not allowed (and hence cannot
be opened/created) on your filesystem. If such an error occurs, a
<a class="reference external" href="reference-Alerts.html#file_error_alert">file_error_alert</a> is generated and all handles that refers to that
torrent will become invalid.</p>
<a name="resume()"></a>
<a name="pause()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bresume%28%29+pause%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bresume%28%29+pause%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="resume-pause">
<h3>resume() pause()</h3>
<pre class="literal-block">
void <strong>resume</strong> () const;
void <strong>pause</strong> (pause_flags_t flags = {}) const;
</pre>
<p><tt class="docutils literal">pause()</tt>, and <tt class="docutils literal">resume()</tt> will disconnect all peers and reconnect
all peers respectively. When a torrent is paused, it will however
remember all share ratios to all peers and remember all potential (not
connected) peers. Torrents may be paused automatically if there is a
file error (e.g. disk full) or something similar. See
<a class="reference external" href="reference-Alerts.html#file_error_alert">file_error_alert</a>.</p>
<p>To know if a torrent is paused or not, call
<tt class="docutils literal"><span class="pre">torrent_handle::status()</span></tt> and inspect <tt class="docutils literal"><span class="pre">torrent_status::paused</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Torrents that are auto-managed may be automatically resumed again. It
does not make sense to pause an auto-managed torrent without making it
not auto-managed first. Torrents are auto-managed by default when added
to the <a class="reference external" href="reference-Session.html#session">session</a>. For more information, see <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
</div>
<a name="set_flags()"></a>
<a name="flags()"></a>
<a name="unset_flags()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_flags%28%29+flags%28%29+unset_flags%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_flags%28%29+flags%28%29+unset_flags%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-flags-flags-unset-flags">
<h3>set_flags() flags() unset_flags()</h3>
<pre class="literal-block">
torrent_flags_t <strong>flags</strong> () const;
void <strong>unset_flags</strong> (torrent_flags_t flags) const;
void <strong>set_flags</strong> (torrent_flags_t flags) const;
void <strong>set_flags</strong> (torrent_flags_t flags, torrent_flags_t mask) const;
</pre>
<p>sets and gets the torrent state flags. See <a class="reference external" href="reference-Core.html#torrent_flags_t">torrent_flags_t</a>.
The <tt class="docutils literal">set_flags</tt> overload that take a mask will affect all
flags part of the mask, and set their values to what the
<tt class="docutils literal">flags</tt> argument is set to. This allows clearing and
setting flags in a single function call.
The <tt class="docutils literal">set_flags</tt> overload that just takes flags, sets all
the specified flags and leave any other flags unchanged.
<tt class="docutils literal">unset_flags</tt> clears the specified flags, while leaving
any other flags unchanged.</p>
<p>The <cite>seed_mode</cite> flag is special, it can only be cleared once the
torrent has been added, and it can only be set as part of the
<a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> flags, when adding the torrent.</p>
<a name="flush_cache()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bflush_cache%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bflush_cache%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="flush-cache">
<h3>flush_cache()</h3>
<pre class="literal-block">
void <strong>flush_cache</strong> () const;
</pre>
<p>Instructs libtorrent to flush all the disk caches for this torrent and
close all file handles. This is done asynchronously and you will be
notified that it's complete through <a class="reference external" href="reference-Alerts.html#cache_flushed_alert">cache_flushed_alert</a>.</p>
<p>Note that by the time you get the <a class="reference external" href="reference-Alerts.html#alert">alert</a>, libtorrent may have cached
more data for the torrent, but you are guaranteed that whatever cached
data libtorrent had by the time you called
<tt class="docutils literal"><span class="pre">torrent_handle::flush_cache()</span></tt> has been written to disk.</p>
<a name="force_recheck()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bforce_recheck%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bforce_recheck%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="force-recheck">
<h3>force_recheck()</h3>
<pre class="literal-block">
void <strong>force_recheck</strong> () const;
</pre>
<p><tt class="docutils literal">force_recheck</tt> puts the torrent back in a state where it assumes to
have no resume data. All peers will be disconnected and the torrent
will stop announcing to the tracker. The torrent will be added to the
checking queue, and will be checked (all the files will be read and
compared to the piece hashes). Once the check is complete, the torrent
will start connecting to peers again, as normal.
The torrent will be placed last in queue, i.e. its queue position
will be the highest of all torrents in the <a class="reference external" href="reference-Session.html#session">session</a>.</p>
<a name="save_resume_data()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bsave_resume_data%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bsave_resume_data%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="save-resume-data">
<h3>save_resume_data()</h3>
<pre class="literal-block">
void <strong>save_resume_data</strong> (resume_data_flags_t flags = {}) const;
</pre>
<p><tt class="docutils literal">save_resume_data()</tt> asks libtorrent to generate fast-resume data for
this torrent.</p>
<p>This operation is asynchronous, <tt class="docutils literal">save_resume_data</tt> will return
immediately. The resume data is delivered when it's done through an
<a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a>.</p>
<p>The fast resume data will be empty in the following cases:</p>
<blockquote>
<ol class="arabic simple">
<li>The torrent handle is invalid.</li>
<li>The torrent hasn't received valid metadata and was started without
metadata (see libtorrent's <a class="reference external" href="manual-ref.html#metadata-from-peers">metadata from peers</a> extension)</li>
</ol>
</blockquote>
<p>Note that by the time you receive the fast resume data, it may already
be invalid if the torrent is still downloading! The recommended
practice is to first pause the <a class="reference external" href="reference-Session.html#session">session</a>, then generate the fast resume
data, and then close it down. Make sure to not <a class="reference external" href="reference-Session.html#remove_torrent()">remove_torrent()</a> before
you receive the <a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a> though. There's no need to
pause when saving intermittent resume data.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If you pause every torrent individually instead of pausing the
<a class="reference external" href="reference-Session.html#session">session</a>, every torrent will have its paused state saved in the
resume data!</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>It is typically a good idea to save resume data whenever a torrent
is completed or paused. In those cases you don't need to pause the
torrent or the <a class="reference external" href="reference-Session.html#session">session</a>, since the torrent will do no more writing to
its files. If you save resume data for torrents when they are
paused, you can accelerate the shutdown process by not saving resume
data again for paused torrents. Completed torrents should have their
resume data saved when they complete and on exit, since their
statistics might be updated.</p>
<blockquote class="last">
In full allocation mode the resume data is never invalidated by
subsequent writes to the files, since pieces won't move around. This
means that you don't need to pause before writing resume data in full
or sparse mode. If you don't, however, any data written to disk after
you saved resume data and before the <a class="reference external" href="reference-Session.html#session">session</a> closed is lost.</blockquote>
</div>
<p>It also means that if the resume data is out dated, libtorrent will
not re-check the files, but assume that it is fairly recent. The
assumption is that it's better to loose a little bit than to re-check
the entire file.</p>
<p>It is still a good idea to save resume data periodically during
download as well as when closing down.</p>
<p>Example code to pause and save resume data for all torrents and wait
for the alerts:</p>
<pre class="code c++ literal-block">
<span class="keyword">extern</span> <span class="keyword type">int</span> <span class="name">outstanding_resume_data</span><span class="punctuation">;</span> <span class="comment single">// global counter of outstanding resume data
</span><span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">torrent_handle</span><span class="operator">&gt;</span> <span class="name">handles</span> <span class="operator">=</span> <span class="name">ses</span><span class="punctuation">.</span><span class="name">get_torrents</span><span class="punctuation">();</span>
<span class="name">ses</span><span class="punctuation">.</span><span class="name">pause</span><span class="punctuation">();</span>
<span class="keyword">for</span> <span class="punctuation">(</span><span class="name">torrent_handle</span> <span class="keyword">const</span><span class="operator">&amp;</span> <span class="name label">h</span> <span class="punctuation">:</span> <span class="name">handles</span><span class="punctuation">)</span>
<span class="punctuation">{</span>
        <span class="keyword">if</span> <span class="punctuation">(</span><span class="operator">!</span><span class="name">h</span><span class="punctuation">.</span><span class="name">is_valid</span><span class="punctuation">())</span> <span class="keyword">continue</span><span class="punctuation">;</span>
        <span class="name">torrent_status</span> <span class="name">s</span> <span class="operator">=</span> <span class="name">h</span><span class="punctuation">.</span><span class="name">status</span><span class="punctuation">();</span>
        <span class="keyword">if</span> <span class="punctuation">(</span><span class="operator">!</span><span class="name">s</span><span class="punctuation">.</span><span class="name">has_metadata</span> <span class="operator">||</span> <span class="operator">!</span><span class="name">s</span><span class="punctuation">.</span><span class="name">need_save_resume_data</span><span class="punctuation">())</span> <span class="keyword">continue</span><span class="punctuation">;</span>

        <span class="name">h</span><span class="punctuation">.</span><span class="name">save_resume_data</span><span class="punctuation">();</span>
        <span class="operator">++</span><span class="name">outstanding_resume_data</span><span class="punctuation">;</span>
<span class="punctuation">}</span>

<span class="keyword">while</span> <span class="punctuation">(</span><span class="name">outstanding_resume_data</span> <span class="operator">&gt;</span> <span class="literal number integer">0</span><span class="punctuation">)</span>
<span class="punctuation">{</span>
        <span class="name">alert</span> <span class="keyword">const</span><span class="operator">*</span> <span class="name">a</span> <span class="operator">=</span> <span class="name">ses</span><span class="punctuation">.</span><span class="name">wait_for_alert</span><span class="punctuation">(</span><span class="name">seconds</span><span class="punctuation">(</span><span class="literal number integer">10</span><span class="punctuation">));</span>

        <span class="comment single">// if we don't get an alert within 10 seconds, abort
</span>        <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">a</span> <span class="operator">==</span> <span class="keyword">nullptr</span><span class="punctuation">)</span> <span class="keyword">break</span><span class="punctuation">;</span>

        <span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="name">alert</span><span class="operator">*&gt;</span> <span class="name">alerts</span><span class="punctuation">;</span>
        <span class="name">ses</span><span class="punctuation">.</span><span class="name">pop_alerts</span><span class="punctuation">(</span><span class="operator">&amp;</span><span class="name">alerts</span><span class="punctuation">);</span>

        <span class="keyword">for</span> <span class="punctuation">(</span><span class="name">alert</span><span class="operator">*</span> <span class="name label">i</span> <span class="punctuation">:</span> <span class="name">alerts</span><span class="punctuation">)</span>
        <span class="punctuation">{</span>
                <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">alert_cast</span><span class="operator">&lt;</span><span class="name">save_resume_data_failed_alert</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">a</span><span class="punctuation">))</span>
                <span class="punctuation">{</span>
                        <span class="name">process_alert</span><span class="punctuation">(</span><span class="name">a</span><span class="punctuation">);</span>
                        <span class="operator">--</span><span class="name">outstanding_resume_data</span><span class="punctuation">;</span>
                        <span class="keyword">continue</span><span class="punctuation">;</span>
                <span class="punctuation">}</span>

                <span class="name">save_resume_data_alert</span> <span class="keyword">const</span><span class="operator">*</span> <span class="name">rd</span> <span class="operator">=</span> <span class="name">alert_cast</span><span class="operator">&lt;</span><span class="name">save_resume_data_alert</span><span class="operator">&gt;</span><span class="punctuation">(</span><span class="name">a</span><span class="punctuation">);</span>
                <span class="keyword">if</span> <span class="punctuation">(</span><span class="name">rd</span> <span class="operator">==</span> <span class="keyword">nullptr</span><span class="punctuation">)</span>
                <span class="punctuation">{</span>
                        <span class="name">process_alert</span><span class="punctuation">(</span><span class="name">a</span><span class="punctuation">);</span>
                        <span class="keyword">continue</span><span class="punctuation">;</span>
                <span class="punctuation">}</span>

                <span class="name">torrent_handle</span> <span class="name">h</span> <span class="operator">=</span> <span class="name">rd</span><span class="operator">-&gt;</span><span class="name">handle</span><span class="punctuation">;</span>
                <span class="name">torrent_status</span> <span class="name">st</span> <span class="operator">=</span> <span class="name">h</span><span class="punctuation">.</span><span class="name">status</span><span class="punctuation">(</span><span class="name">torrent_handle</span><span class="operator">::</span><span class="name">query_save_path</span>
                        <span class="operator">|</span> <span class="name">torrent_handle</span><span class="operator">::</span><span class="name">query_name</span><span class="punctuation">);</span>
                <span class="name">std</span><span class="operator">::</span><span class="name">ofstream</span> <span class="name">out</span><span class="punctuation">((</span><span class="name">st</span><span class="punctuation">.</span><span class="name">save_path</span>
                        <span class="operator">+</span> <span class="literal string">&quot;/&quot;</span> <span class="operator">+</span> <span class="name">st</span><span class="punctuation">.</span><span class="name">name</span> <span class="operator">+</span> <span class="literal string">&quot;.fastresume&quot;</span><span class="punctuation">).</span><span class="name">c_str</span><span class="punctuation">()</span>
                        <span class="punctuation">,</span> <span class="name">std</span><span class="operator">::</span><span class="name">ios_base</span><span class="operator">::</span><span class="name">binary</span><span class="punctuation">);</span>
                <span class="name">std</span><span class="operator">::</span><span class="name">vector</span><span class="operator">&lt;</span><span class="keyword type">char</span><span class="operator">&gt;</span> <span class="name">buf</span> <span class="operator">=</span> <span class="name">write_resume_data_buf</span><span class="punctuation">(</span><span class="name">rd</span><span class="operator">-&gt;</span><span class="name">params</span><span class="punctuation">);</span>
                <span class="name">out</span><span class="punctuation">.</span><span class="name">write</span><span class="punctuation">(</span><span class="name">buf</span><span class="punctuation">.</span><span class="name">data</span><span class="punctuation">(),</span> <span class="name">buf</span><span class="punctuation">.</span><span class="name">size</span><span class="punctuation">());</span>
                <span class="operator">--</span><span class="name">outstanding_resume_data</span><span class="punctuation">;</span>
        <span class="punctuation">}</span>
<span class="punctuation">}</span>
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Note how <tt class="docutils literal">outstanding_resume_data</tt> is a global counter in this
example. This is deliberate, otherwise there is a race condition for
torrents that was just asked to save their resume data, they posted
the <a class="reference external" href="reference-Alerts.html#alert">alert</a>, but it has not been received yet. Those torrents would
report that they don't need to save resume data again, and skipped by
the initial loop, and thwart the counter otherwise.</p>
</div>
<a name="need_save_resume_data()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bneed_save_resume_data%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bneed_save_resume_data%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="need-save-resume-data">
<h3>need_save_resume_data()</h3>
<pre class="literal-block">
bool <strong>need_save_resume_data</strong> () const;
</pre>
<p>This function returns true if any whole chunk has been downloaded
since the torrent was first loaded or since the last time the resume
data was saved. When saving resume data periodically, it makes sense
to skip any torrent which hasn't downloaded anything since the last
time.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A torrent's resume data is considered saved as soon as the
<a class="reference external" href="reference-Alerts.html#save_resume_data_alert">save_resume_data_alert</a> is posted. It is important to make sure this
<a class="reference external" href="reference-Alerts.html#alert">alert</a> is received and handled in order for this function to be
meaningful.</p>
</div>
<a name="queue_position()"></a>
<a name="queue_position_top()"></a>
<a name="queue_position_down()"></a>
<a name="queue_position_up()"></a>
<a name="queue_position_bottom()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bqueue_position%28%29+queue_position_top%28%29+queue_position_down%28%29+queue_position_up%28%29+queue_position_bottom%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bqueue_position%28%29+queue_position_top%28%29+queue_position_down%28%29+queue_position_up%28%29+queue_position_bottom%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="queue-position-queue-position-top-queue-position-down-queue-position-up-queue-position-bottom">
<h3>queue_position() queue_position_top() queue_position_down() queue_position_up() queue_position_bottom()</h3>
<pre class="literal-block">
queue_position_t <strong>queue_position</strong> () const;
void <strong>queue_position_down</strong> () const;
void <strong>queue_position_up</strong> () const;
void <strong>queue_position_bottom</strong> () const;
void <strong>queue_position_top</strong> () const;
</pre>
<p>Every torrent that is added is assigned a queue position exactly one
greater than the greatest queue position of all existing torrents.
Torrents that are being seeded have -1 as their queue position, since
they're no longer in line to be downloaded.</p>
<p>When a torrent is removed or turns into a seed, all torrents with
greater queue positions have their positions decreased to fill in the
space in the sequence.</p>
<p><tt class="docutils literal">queue_position()</tt> returns the torrent's position in the download
queue. The torrents with the smallest numbers are the ones that are
being downloaded. The smaller number, the closer the torrent is to the
front of the line to be started.</p>
<p>The queue position is also available in the <a class="reference external" href="reference-Core.html#torrent_status">torrent_status</a>.</p>
<p>The <tt class="docutils literal"><span class="pre">queue_position_*()</span></tt> functions adjust the torrents position in
the queue. Up means closer to the front and down means closer to the
back of the queue. Top and bottom refers to the front and the back of
the queue respectively.</p>
<a name="queue_position_set()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bqueue_position_set%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bqueue_position_set%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="queue-position-set">
<h3>queue_position_set()</h3>
<pre class="literal-block">
void <strong>queue_position_set</strong> (queue_position_t p) const;
</pre>
<p>updates the position in the queue for this torrent. The relative order
of all other torrents remain intact but their numerical queue position
shifts to make space for this torrent's new position</p>
<a name="set_ssl_certificate()"></a>
<a name="set_ssl_certificate_buffer()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_ssl_certificate%28%29+set_ssl_certificate_buffer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_ssl_certificate%28%29+set_ssl_certificate_buffer%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-ssl-certificate-set-ssl-certificate-buffer">
<h3>set_ssl_certificate() set_ssl_certificate_buffer()</h3>
<pre class="literal-block">
void <strong>set_ssl_certificate</strong> (std::string const&amp; certificate
      , std::string const&amp; private_key
      , std::string const&amp; dh_params
      , std::string const&amp; passphrase = &quot;&quot;);
void <strong>set_ssl_certificate_buffer</strong> (std::string const&amp; certificate
      , std::string const&amp; private_key
      , std::string const&amp; dh_params);
</pre>
<p>For SSL torrents, use this to specify a path to a .pem file to use as
this client's certificate. The certificate must be signed by the
certificate in the .torrent file to be valid.</p>
<p>The <a class="reference external" href="reference-Core.html#set_ssl_certificate_buffer()">set_ssl_certificate_buffer()</a> overload takes the actual certificate,
private key and DH params as strings, rather than paths to files.</p>
<p><tt class="docutils literal">cert</tt> is a path to the (signed) certificate in .pem format
corresponding to this torrent.</p>
<p><tt class="docutils literal">private_key</tt> is a path to the private key for the specified
certificate. This must be in .pem format.</p>
<p><tt class="docutils literal">dh_params</tt> is a path to the Diffie-Hellman parameter file, which
needs to be in .pem format. You can generate this file using the
openssl command like this: <tt class="docutils literal">openssl dhparam <span class="pre">-outform</span> PEM <span class="pre">-out</span>
dhparams.pem 512</tt>.</p>
<p><tt class="docutils literal">passphrase</tt> may be specified if the private key is encrypted and
requires a passphrase to be decrypted.</p>
<p>Note that when a torrent first starts up, and it needs a certificate,
it will suspend connecting to any peers until it has one. It's
typically desirable to resume the torrent after setting the SSL
certificate.</p>
<p>If you receive a <a class="reference external" href="reference-Alerts.html#torrent_need_cert_alert">torrent_need_cert_alert</a>, you need to call this to
provide a valid cert. If you don't have a cert you won't be allowed to
connect to any peers.</p>
<a name="get_storage_impl()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bget_storage_impl%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bget_storage_impl%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-storage-impl">
<h3>get_storage_impl()</h3>
<pre class="literal-block">
storage_interface* <strong>get_storage_impl</strong> () const;
</pre>
<p>Returns the storage implementation for this torrent. This depends on the
storage constructor function that was passed to add_torrent.</p>
<a name="torrent_file()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Btorrent_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Btorrent_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-file">
<h3>torrent_file()</h3>
<pre class="literal-block">
std::shared_ptr&lt;const torrent_info&gt; <strong>torrent_file</strong> () const;
</pre>
<p>Returns a pointer to the <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object associated with this
torrent. The <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object may be a copy of the internal object.
If the torrent doesn't have metadata, the pointer will not be
initialized (i.e. a nullptr). The torrent may be in a state
without metadata only if it was started without a .torrent file, e.g.
by being added by magnet link</p>
<a name="piece_availability()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpiece_availability%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpiece_availability%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-availability">
<h3>piece_availability()</h3>
<pre class="literal-block">
void <strong>piece_availability</strong> (std::vector&lt;int&gt;&amp; avail) const;
</pre>
<p>Fills the specified <tt class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></tt> with the availability for
each piece in this torrent. libtorrent does not keep track of
availability for seeds, so if the torrent is seeding the availability
for all pieces is reported as 0.</p>
<p>The piece availability is the number of peers that we are connected
that has advertised having a particular piece. This is the information
that libtorrent uses in order to prefer picking rare pieces.</p>
<a name="piece_priority()"></a>
<a name="prioritize_pieces()"></a>
<a name="get_piece_priorities()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bpiece_priority%28%29+prioritize_pieces%28%29+get_piece_priorities%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bpiece_priority%28%29+prioritize_pieces%28%29+get_piece_priorities%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-priority-prioritize-pieces-get-piece-priorities">
<h3>piece_priority() prioritize_pieces() get_piece_priorities()</h3>
<pre class="literal-block">
void <strong>prioritize_pieces</strong> (std::vector&lt;download_priority_t&gt; const&amp; pieces) const;
download_priority_t <strong>piece_priority</strong> (piece_index_t index) const;
void <strong>prioritize_pieces</strong> (std::vector&lt;std::pair&lt;piece_index_t, download_priority_t&gt;&gt; const&amp; pieces) const;
void <strong>piece_priority</strong> (piece_index_t index, download_priority_t priority) const;
std::vector&lt;download_priority_t&gt; <strong>get_piece_priorities</strong> () const;
</pre>
<p>These functions are used to set and get the priority of individual
pieces. By default all pieces have priority 4. That means that the
random rarest first algorithm is effectively active for all pieces.
You may however change the priority of individual pieces. There are 8
priority levels. 0 means not to download the piece at all. Otherwise,
lower priority values means less likely to be picked. Piece priority
takes precedence over piece availability. Every piece with priority 7
will be attempted to be picked before a priority 6 piece and so on.</p>
<p>The default priority of pieces is 4.</p>
<p>Piece priorities can not be changed for torrents that have not
downloaded the metadata yet. Magnet links won't have metadata
immediately. see the <a class="reference external" href="reference-Alerts.html#metadata_received_alert">metadata_received_alert</a>.</p>
<p><tt class="docutils literal">piece_priority</tt> sets or gets the priority for an individual piece,
specified by <tt class="docutils literal">index</tt>.</p>
<p><tt class="docutils literal">prioritize_pieces</tt> takes a vector of integers, one integer per
piece in the torrent. All the piece priorities will be updated with
the priorities in the vector.
The second overload of <tt class="docutils literal">prioritize_pieces</tt> that takes a vector of pairs
will update the priorities of only select pieces, and leave all other
unaffected. Each pair is (piece, priority). That is, the first item is
the piece index and the second item is the priority of that piece.
Invalid entries, where the piece index or priority is out of range, are
not allowed.</p>
<p><tt class="docutils literal">get_piece_priorities</tt> returns a vector with one element for each piece
in the torrent. Each element is the current priority of that piece.</p>
<p>It's possible to cancel the effect of <em>file</em> priorities by setting the
priorities for the affected pieces. Care has to be taken when mixing
usage of file- and piece priorities.</p>
<a name="get_file_priorities()"></a>
<a name="file_priority()"></a>
<a name="prioritize_files()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bget_file_priorities%28%29+file_priority%28%29+prioritize_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bget_file_priorities%28%29+file_priority%28%29+prioritize_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="get-file-priorities-file-priority-prioritize-files">
<h3>get_file_priorities() file_priority() prioritize_files()</h3>
<pre class="literal-block">
void <strong>prioritize_files</strong> (std::vector&lt;download_priority_t&gt; const&amp; files) const;
void <strong>file_priority</strong> (file_index_t index, download_priority_t priority) const;
std::vector&lt;download_priority_t&gt; <strong>get_file_priorities</strong> () const;
download_priority_t <strong>file_priority</strong> (file_index_t index) const;
</pre>
<p><tt class="docutils literal">index</tt> must be in the range [0, number_of_files).</p>
<p><tt class="docutils literal">file_priority()</tt> queries or sets the priority of file <tt class="docutils literal">index</tt>.</p>
<p><tt class="docutils literal">prioritize_files()</tt> takes a vector that has at as many elements as
there are files in the torrent. Each <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is the priority of that
file. The function sets the priorities of all the pieces in the
torrent based on the vector.</p>
<p><tt class="docutils literal">get_file_priorities()</tt> returns a vector with the priorities of all
files.</p>
<p>The priority values are the same as for <a class="reference external" href="reference-Core.html#piece_priority()">piece_priority()</a>. See
<a class="reference external" href="reference-Core.html#download_priority_t">download_priority_t</a>.</p>
<p>Whenever a file priority is changed, all other piece priorities are
reset to match the file priorities. In order to maintain special
priorities for particular pieces, <a class="reference external" href="reference-Core.html#piece_priority()">piece_priority()</a> has to be called
again for those pieces.</p>
<p>You cannot set the file priorities on a torrent that does not yet have
metadata or a torrent that is a seed. <tt class="docutils literal">file_priority(int, int)</tt> and
<a class="reference external" href="reference-Core.html#prioritize_files()">prioritize_files()</a> are both no-ops for such torrents.</p>
<p>Since changing file priorities may involve disk operations (of moving
files in- and out of the part file), the internal accounting of file
priorities happen asynchronously. i.e. setting file priorities and then
immediately querying them may not yield the same priorities just set.
However, the <em>piece</em> priorities are updated immediately.</p>
<p>when combining file- and piece priorities, the resume file will record
both. When loading the resume data, the file priorities will be applied
first, then the piece priorities.</p>
<a name="force_reannounce()"></a>
<a name="force_dht_announce()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bforce_reannounce%28%29+force_dht_announce%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bforce_reannounce%28%29+force_dht_announce%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="force-reannounce-force-dht-announce">
<h3>force_reannounce() force_dht_announce()</h3>
<pre class="literal-block">
void <strong>force_reannounce</strong> (int seconds = 0, int tracker_index = -1, reannounce_flags_t = {}) const;
void <strong>force_dht_announce</strong> () const;
</pre>
<p><tt class="docutils literal">force_reannounce()</tt> will force this torrent to do another tracker
request, to receive new peers. The <tt class="docutils literal">seconds</tt> argument specifies how
many seconds from now to issue the tracker announces.</p>
<p>If the tracker's <tt class="docutils literal">min_interval</tt> has not passed since the last
announce, the forced announce will be scheduled to happen immediately
as the <tt class="docutils literal">min_interval</tt> expires. This is to honor trackers minimum
re-announce interval settings.</p>
<p>The <tt class="docutils literal">tracker_index</tt> argument specifies which tracker to re-announce.
If set to -1 (which is the default), all trackers are re-announce.</p>
<p>The <tt class="docutils literal">flags</tt> argument can be used to affect the re-announce. See
ignore_min_interval.</p>
<p><tt class="docutils literal">force_dht_announce</tt> will announce the torrent to the DHT
immediately.</p>
<a name="scrape_tracker()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bscrape_tracker%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bscrape_tracker%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="scrape-tracker">
<h3>scrape_tracker()</h3>
<pre class="literal-block">
void <strong>scrape_tracker</strong> (int idx = -1) const;
</pre>
<p><tt class="docutils literal">scrape_tracker()</tt> will send a scrape request to a tracker. By
default (<tt class="docutils literal">idx</tt> = -1) it will scrape the last working tracker. If
<tt class="docutils literal">idx</tt> is &gt;= 0, the tracker with the specified index will scraped.</p>
<p>A scrape request queries the tracker for statistics such as total
number of incomplete peers, complete peers, number of downloads etc.</p>
<p>This request will specifically update the <tt class="docutils literal">num_complete</tt> and
<tt class="docutils literal">num_incomplete</tt> fields in the <a class="reference external" href="reference-Core.html#torrent_status">torrent_status</a> struct once it
completes. When it completes, it will generate a <a class="reference external" href="reference-Alerts.html#scrape_reply_alert">scrape_reply_alert</a>.
If it fails, it will generate a <a class="reference external" href="reference-Alerts.html#scrape_failed_alert">scrape_failed_alert</a>.</p>
<a name="upload_limit()"></a>
<a name="download_limit()"></a>
<a name="set_download_limit()"></a>
<a name="set_upload_limit()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bupload_limit%28%29+download_limit%28%29+set_download_limit%28%29+set_upload_limit%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bupload_limit%28%29+download_limit%28%29+set_download_limit%28%29+set_upload_limit%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="upload-limit-download-limit-set-download-limit-set-upload-limit">
<h3>upload_limit() download_limit() set_download_limit() set_upload_limit()</h3>
<pre class="literal-block">
int <strong>upload_limit</strong> () const;
void <strong>set_upload_limit</strong> (int limit) const;
int <strong>download_limit</strong> () const;
void <strong>set_download_limit</strong> (int limit) const;
</pre>
<p><tt class="docutils literal">set_upload_limit</tt> will limit the upload bandwidth used by this
particular torrent to the limit you set. It is given as the number of
bytes per second the torrent is allowed to upload.
<tt class="docutils literal">set_download_limit</tt> works the same way but for download bandwidth
instead of upload bandwidth. Note that setting a higher limit on a
torrent then the global limit
(<tt class="docutils literal"><span class="pre">settings_pack::upload_rate_limit</span></tt>) will not override the global
rate limit. The torrent can never upload more than the global rate
limit.</p>
<p><tt class="docutils literal">upload_limit</tt> and <tt class="docutils literal">download_limit</tt> will return the current limit
setting, for upload and download, respectively.</p>
<p>Local peers are not rate limited by default. see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
<a name="connect_peer()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bconnect_peer%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bconnect_peer%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="connect-peer">
<h3>connect_peer()</h3>
<pre class="literal-block">
void <strong>connect_peer</strong> (tcp::endpoint const&amp; adr, peer_source_flags_t source = {}
      , pex_flags_t flags = pex_encryption | pex_utp | pex_holepunch) const;
</pre>
<p><tt class="docutils literal">connect_peer()</tt> is a way to manually connect to peers that one
believe is a part of the torrent. If the peer does not respond, or is
not a member of this torrent, it will simply be disconnected. No harm
can be done by using this other than an unnecessary connection attempt
is made. If the torrent is uninitialized or in queued or checking
mode, this will throw system_error. The second (optional)
argument will be bitwise ORed into the source mask of this peer.
Typically this is one of the source flags in <a class="reference external" href="reference-Core.html#peer_info">peer_info</a>. i.e.
<tt class="docutils literal">tracker</tt>, <tt class="docutils literal">pex</tt>, <tt class="docutils literal">dht</tt> etc.</p>
<p>For possible values of <tt class="docutils literal">flags</tt>, see <a class="reference external" href="reference-Core.html#pex_flags_t">pex_flags_t</a>.</p>
<a name="clear_peers()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bclear_peers%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bclear_peers%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="clear-peers">
<h3>clear_peers()</h3>
<pre class="literal-block">
void <strong>clear_peers</strong> ();
</pre>
<p>This will disconnect all peers and clear the peer list for this
torrent. New peers will have to be acquired before resuming, from
trackers, DHT or local service discovery, for example.</p>
<a name="max_uploads()"></a>
<a name="set_max_uploads()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bmax_uploads%28%29+set_max_uploads%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bmax_uploads%28%29+set_max_uploads%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="max-uploads-set-max-uploads">
<h3>max_uploads() set_max_uploads()</h3>
<pre class="literal-block">
void <strong>set_max_uploads</strong> (int max_uploads) const;
int <strong>max_uploads</strong> () const;
</pre>
<p><tt class="docutils literal">set_max_uploads()</tt> sets the maximum number of peers that's unchoked
at the same time on this torrent. If you set this to -1, there will be
no limit. This defaults to infinite. The primary setting controlling
this is the global unchoke slots limit, set by unchoke_slots_limit in
<a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.</p>
<p><tt class="docutils literal">max_uploads()</tt> returns the current settings.</p>
<a name="set_max_connections()"></a>
<a name="max_connections()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bset_max_connections%28%29+max_connections%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bset_max_connections%28%29+max_connections%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-max-connections-max-connections">
<h3>set_max_connections() max_connections()</h3>
<pre class="literal-block">
int <strong>max_connections</strong> () const;
void <strong>set_max_connections</strong> (int max_connections) const;
</pre>
<p><tt class="docutils literal">set_max_connections()</tt> sets the maximum number of connection this
torrent will open. If all connections are used up, incoming
connections may be refused or poor connections may be closed. This
must be at least 2. The default is unlimited number of connections. If
-1 is given to the function, it means unlimited. There is also a
global limit of the number of connections, set by
<tt class="docutils literal">connections_limit</tt> in <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.</p>
<p><tt class="docutils literal">max_connections()</tt> returns the current settings.</p>
<a name="move_storage()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bmove_storage%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bmove_storage%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="move-storage">
<h3>move_storage()</h3>
<pre class="literal-block">
void <strong>move_storage</strong> (std::string const&amp; save_path
      , move_flags_t flags = move_flags_t::always_replace_files
      ) const;
</pre>
<p>Moves the file(s) that this torrent are currently seeding from or
downloading to. If the given <tt class="docutils literal">save_path</tt> is not located on the same
drive as the original save path, the files will be copied to the new
drive and removed from their original location. This will block all
other disk IO, and other torrents download and upload rates may drop
while copying the file.</p>
<p>Since disk IO is performed in a separate thread, this operation is
also asynchronous. Once the operation completes, the
<tt class="docutils literal">storage_moved_alert</tt> is generated, with the new path as the
message. If the move fails for some reason,
<tt class="docutils literal">storage_moved_failed_alert</tt> is generated instead, containing the
error message.</p>
<p>The <tt class="docutils literal">flags</tt> argument determines the behavior of the copying/moving
of the files in the torrent. see <a class="reference external" href="reference-Storage.html#move_flags_t">move_flags_t</a>.</p>
<p><tt class="docutils literal">always_replace_files</tt> is the default and replaces any file that
exist in both the source directory and the target directory.</p>
<p><tt class="docutils literal">fail_if_exist</tt> first check to see that none of the copy operations
would cause an overwrite. If it would, it will fail. Otherwise it will
proceed as if it was in <tt class="docutils literal">always_replace_files</tt> mode. Note that there
is an inherent race condition here. If the files in the target
directory appear after the check but before the copy or move
completes, they will be overwritten. When failing because of files
already existing in the target path, the <tt class="docutils literal">error</tt> of
<tt class="docutils literal">move_storage_failed_alert</tt> is set to
<tt class="docutils literal"><span class="pre">boost::system::errc::file_exists</span></tt>.</p>
<p>The intention is that a client may use this as a probe, and if it
fails, ask the user which mode to use. The client may then re-issue
the <tt class="docutils literal">move_storage</tt> call with one of the other modes.</p>
<p><tt class="docutils literal">dont_replace</tt> always keeps the existing file in the target
directory, if there is one. The source files will still be removed in
that case. Note that it won't automatically re-check files. If an
incomplete torrent is moved into a directory with the complete files,
pause, move, force-recheck and resume. Without the re-checking, the
torrent will keep downloading and files in the new download directory
will be overwritten.</p>
<p>Files that have been renamed to have absolute paths are not moved by
this function. Keep in mind that files that don't belong to the
torrent but are stored in the torrent's directory may be moved as
well. This goes for files that have been renamed to absolute paths
that still end up inside the save path.</p>
<a name="rename_file()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Brename_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Brename_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="rename-file">
<h3>rename_file()</h3>
<pre class="literal-block">
void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_name) const;
</pre>
<p>Renames the file with the given index asynchronously. The rename
operation is complete when either a <a class="reference external" href="reference-Alerts.html#file_renamed_alert">file_renamed_alert</a> or
<a class="reference external" href="reference-Alerts.html#file_rename_failed_alert">file_rename_failed_alert</a> is posted.</p>
<a name="info_hash()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Binfo_hash%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Binfo_hash%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="info-hash">
<h3>info_hash()</h3>
<pre class="literal-block">
sha1_hash <strong>info_hash</strong> () const;
</pre>
<p><tt class="docutils literal">info_hash()</tt> returns the info-hash of the torrent. If this handle
is to a torrent that hasn't loaded yet (for instance by being added)
by a URL, the returned value is undefined.</p>
<a name="operator==()"></a>
<a name="operator!=()"></a>
<a name="operator<()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Boperator%3D%3D%28%29+operator%21%3D%28%29+operator%3C%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Boperator%3D%3D%28%29+operator%21%3D%28%29+operator%3C%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="operator-operator-operator">
<h3>operator==() operator!=() operator&lt;()</h3>
<pre class="literal-block">
bool <strong>operator!=</strong> (const torrent_handle&amp; h) const;
bool <strong>operator&lt;</strong> (const torrent_handle&amp; h) const;
bool <strong>operator==</strong> (const torrent_handle&amp; h) const;
</pre>
<p>comparison operators. The order of the torrents is unspecified
but stable.</p>
<a name="id()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bid%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bid%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="id">
<h3>id()</h3>
<pre class="literal-block">
std::uint32_t <strong>id</strong> () const;
</pre>
<p>returns a unique identifier for this torrent. It's not a dense index.
It's not preserved across sessions.</p>
<a name="native_handle()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bnative_handle%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bnative_handle%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="native-handle">
<h3>native_handle()</h3>
<pre class="literal-block">
std::shared_ptr&lt;torrent&gt; <strong>native_handle</strong> () const;
</pre>
<p>This function is intended only for use by plugins and the <a class="reference external" href="reference-Alerts.html#alert">alert</a>
dispatch function. This type does not have a stable ABI and should
be relied on as little as possible. Accessing the handle returned by
this function is not thread safe outside of libtorrent's internal
thread (which is used to invoke <a class="reference external" href="reference-Plugins.html#plugin">plugin</a> callbacks).
The <tt class="docutils literal">torrent</tt> class is not only eligible for changing ABI across
minor versions of libtorrent, its layout is also dependent on build
configuration. This adds additional requirements on a client to be
built with the exact same build configuration as libtorrent itself.
i.e. the <tt class="docutils literal">TORRENT_</tt> macros must match between libtorrent and the
client builds.</p>
<a name="file_progress_flags_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+file_progress_flags_t&labels=documentation&body=Documentation+under+heading+%22enum+file_progress_flags_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-file-progress-flags-t">
<h3>enum file_progress_flags_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%" />
<col width="7%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>piece_granularity</td>
<td>1</td>
<td>only calculate file progress at piece granularity. This makes
the <a class="reference external" href="reference-Core.html#file_progress()">file_progress()</a> call cheaper and also only takes bytes that
have passed the hash check into account, so progress cannot
regress in this mode.</td>
</tr>
</tbody>
</table>
<a name="overwrite_existing"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Boverwrite_existing%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Boverwrite_existing%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>overwrite_existing</dt>
<dd>instruct libtorrent to overwrite any data that may already have been
downloaded with the data of the new piece being added.</dd>
</dl>
<a name="query_distributed_copies"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_distributed_copies%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_distributed_copies%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_distributed_copies</dt>
<dd>calculates <tt class="docutils literal">distributed_copies</tt>, <tt class="docutils literal">distributed_full_copies</tt> and
<tt class="docutils literal">distributed_fraction</tt>.</dd>
</dl>
<a name="query_accurate_download_counters"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_accurate_download_counters%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_accurate_download_counters%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_accurate_download_counters</dt>
<dd>includes partial downloaded blocks in <tt class="docutils literal">total_done</tt> and
<tt class="docutils literal">total_wanted_done</tt>.</dd>
</dl>
<a name="query_last_seen_complete"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_last_seen_complete%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_last_seen_complete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_last_seen_complete</dt>
<dd>includes <tt class="docutils literal">last_seen_complete</tt>.</dd>
</dl>
<a name="query_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_pieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_pieces</dt>
<dd>populate the <tt class="docutils literal">pieces</tt> field in <a class="reference external" href="reference-Core.html#torrent_status">torrent_status</a>.</dd>
</dl>
<a name="query_verified_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_verified_pieces%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_verified_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_verified_pieces</dt>
<dd>includes <tt class="docutils literal">verified_pieces</tt> (only applies to torrents in <em>seed
mode</em>).</dd>
</dl>
<a name="query_torrent_file"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_torrent_file%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_torrent_file%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_torrent_file</dt>
<dd>includes <tt class="docutils literal">torrent_file</tt>, which is all the static information from
the .torrent file.</dd>
</dl>
<a name="query_name"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_name%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_name%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_name</dt>
<dd>includes <tt class="docutils literal">name</tt>, the name of the torrent. This is either derived
from the .torrent file, or from the <tt class="docutils literal">&amp;dn=</tt> magnet link argument
or possibly some other source. If the name of the torrent is not
known, this is an empty string.</dd>
</dl>
<a name="query_save_path"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bquery_save_path%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bquery_save_path%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>query_save_path</dt>
<dd>includes <tt class="docutils literal">save_path</tt>, the path to the directory the files of the
torrent are saved to.</dd>
</dl>
<a name="alert_when_available"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Balert_when_available%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Balert_when_available%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>alert_when_available</dt>
<dd>used to ask libtorrent to send an <a class="reference external" href="reference-Alerts.html#alert">alert</a> once the piece has been
downloaded, by passing alert_when_available. When set, the
<a class="reference external" href="reference-Alerts.html#read_piece_alert">read_piece_alert</a> <a class="reference external" href="reference-Alerts.html#alert">alert</a> will be delivered, with the piece data, when
it's downloaded.</dd>
</dl>
<a name="graceful_pause"></a>
<a name="clear_disk_cache"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bgraceful_pause+clear_disk_cache%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bgraceful_pause+clear_disk_cache%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>graceful_pause clear_disk_cache</dt>
<dd>will delay the disconnect of peers that we're still downloading
outstanding requests from. The torrent will not accept any more
requests and will disconnect all idle peers. As soon as a peer is done
transferring the blocks that were requested from it, it is
disconnected. This is a graceful shut down of the torrent in the sense
that no downloaded bytes are wasted.</dd>
</dl>
<a name="flush_disk_cache"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bflush_disk_cache%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bflush_disk_cache%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flush_disk_cache</dt>
<dd>the disk cache will be flushed before creating the resume data.
This avoids a problem with file timestamps in the resume data in
case the cache hasn't been flushed yet.</dd>
</dl>
<a name="save_info_dict"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bsave_info_dict%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bsave_info_dict%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_info_dict</dt>
<dd>the resume data will contain the metadata from the torrent file as
well. This is default for any torrent that's added without a
torrent file (such as a magnet link or a URL).</dd>
</dl>
<a name="only_if_modified"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bonly_if_modified%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bonly_if_modified%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>only_if_modified</dt>
<dd>if nothing significant has changed in the torrent since the last
time resume data was saved, fail this attempt. Significant changes
primarily include more data having been downloaded, file or piece
priorities having changed etc. If the resume data doesn't need
saving, a <a class="reference external" href="reference-Alerts.html#save_resume_data_failed_alert">save_resume_data_failed_alert</a> is posted with the error
resume_data_not_modified.</dd>
</dl>
<a name="ignore_min_interval"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_handle%3A%3A%5Bignore_min_interval%5D&labels=documentation&body=Documentation+under+heading+%22torrent_handle%3A%3A%5Bignore_min_interval%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ignore_min_interval</dt>
<dd>by default, force-reannounce will still honor the min-interval
published by the tracker. If this flag is set, it will be ignored
and the tracker is announced immediately.</dd>
</dl>
<a name="cache_status"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+cache_status&labels=documentation&body=Documentation+under+heading+%22class+cache_status%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="cache-status">
<h2>cache_status</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/disk_io_thread.hpp">libtorrent/disk_io_thread.hpp</a>&quot;</p>
<p>this struct holds a number of statistics counters
relevant for the disk io thread and disk cache.</p>
<pre class="literal-block">
struct cache_status
{
   <strong>cache_status</strong> ();

   std::vector&lt;cached_piece_info&gt; pieces;
};
</pre>
<a name="cache_status()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:cache_status%3A%3A%5Bcache_status%28%29%5D&labels=documentation&body=Documentation+under+heading+%22cache_status%3A%3A%5Bcache_status%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="id133">
<h3>cache_status()</h3>
<pre class="literal-block">
<strong>cache_status</strong> ();
</pre>
<p>initializes all counters to 0</p>
<a name="web_seed_entry"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+web_seed_entry&labels=documentation&body=Documentation+under+heading+%22class+web_seed_entry%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="web-seed-entry">
<h2>web_seed_entry</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_info.hpp">libtorrent/torrent_info.hpp</a>&quot;</p>
<p>the <a class="reference external" href="reference-Core.html#web_seed_entry">web_seed_entry</a> holds information about a web seed (also known
as URL seed or HTTP seed). It is essentially a URL with some state
associated with it. For more information, see <a class="reference external" href="https://www.bittorrent.org/beps/bep_0017.html">BEP 17</a> and <a class="reference external" href="https://www.bittorrent.org/beps/bep_0019.html">BEP 19</a>.</p>
<pre class="literal-block">
struct web_seed_entry
{
   bool <strong>operator==</strong> (web_seed_entry const&amp; e) const;
   bool <strong>operator&lt;</strong> (web_seed_entry const&amp; e) const;

   enum type_t
   {
      url_seed,
      http_seed,
   };

   std::string url;
   std::string auth;
   headers_t extra_headers;
   std::uint8_t type;
};
</pre>
<a name="operator==()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Boperator%3D%3D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Boperator%3D%3D%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="id136">
<h3>operator==()</h3>
<pre class="literal-block">
bool <strong>operator==</strong> (web_seed_entry const&amp; e) const;
</pre>
<p>URL and type comparison</p>
<a name="operator<()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Boperator%3C%28%29%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Boperator%3C%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="id137">
<h3>operator&lt;()</h3>
<pre class="literal-block">
bool <strong>operator&lt;</strong> (web_seed_entry const&amp; e) const;
</pre>
<p>URL and type less-than comparison</p>
<a name="type_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+type_t&labels=documentation&body=Documentation+under+heading+%22enum+type_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-type-t">
<h3>enum type_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_info.hpp">libtorrent/torrent_info.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="35%" />
<col width="23%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>url_seed</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>http_seed</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="url"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Burl%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Burl%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>url</dt>
<dd>The URL of the web seed</dd>
</dl>
<a name="auth"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Bauth%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Bauth%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>auth</dt>
<dd>Optional authentication. If this is set, it's passed
in as HTTP basic auth to the web seed. The format is:
username:password.</dd>
</dl>
<a name="extra_headers"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Bextra_headers%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Bextra_headers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>extra_headers</dt>
<dd>Any extra HTTP headers that need to be passed to the web seed</dd>
</dl>
<a name="type"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:web_seed_entry%3A%3A%5Btype%5D&labels=documentation&body=Documentation+under+heading+%22web_seed_entry%3A%3A%5Btype%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>type</dt>
<dd>The type of web seed (see <a class="reference external" href="reference-Core.html#type_t">type_t</a>)</dd>
</dl>
<a name="load_torrent_limits"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+load_torrent_limits&labels=documentation&body=Documentation+under+heading+%22class+load_torrent_limits%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="load-torrent-limits">
<h2>load_torrent_limits</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_info.hpp">libtorrent/torrent_info.hpp</a>&quot;</p>
<p>this object holds configuration options for limits to use when loading
torrents. They are meant to prevent loading potentially malicious torrents
that cause excessive memory allocations.</p>
<pre class="literal-block">
struct load_torrent_limits
{
   int <strong>max_buffer_size</strong>  = 10000000;
   int <strong>max_pieces</strong>  = 0x200000;
   int <strong>max_decode_depth</strong>  = 100;
   int <strong>max_decode_tokens</strong>  = 3000000;
};
</pre>
<a name="max_buffer_size"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_limits%3A%3A%5Bmax_buffer_size%5D&labels=documentation&body=Documentation+under+heading+%22load_torrent_limits%3A%3A%5Bmax_buffer_size%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_buffer_size</dt>
<dd>the max size of a .torrent file to load into RAM</dd>
</dl>
<a name="max_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_limits%3A%3A%5Bmax_pieces%5D&labels=documentation&body=Documentation+under+heading+%22load_torrent_limits%3A%3A%5Bmax_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_pieces</dt>
<dd>the max number of pieces allowed in the torrent</dd>
</dl>
<a name="max_decode_depth"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_limits%3A%3A%5Bmax_decode_depth%5D&labels=documentation&body=Documentation+under+heading+%22load_torrent_limits%3A%3A%5Bmax_decode_depth%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_decode_depth</dt>
<dd>the max recursion depth in the bdecoded structure</dd>
</dl>
<a name="max_decode_tokens"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:load_torrent_limits%3A%3A%5Bmax_decode_tokens%5D&labels=documentation&body=Documentation+under+heading+%22load_torrent_limits%3A%3A%5Bmax_decode_tokens%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_decode_tokens</dt>
<dd>the max number of bdecode tokens</dd>
</dl>
<a name="torrent_info"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+torrent_info&labels=documentation&body=Documentation+under+heading+%22class+torrent_info%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-info">
<h2>torrent_info</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_info.hpp">libtorrent/torrent_info.hpp</a>&quot;</p>
<p>the <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> class holds the information found in a .torrent file.</p>
<pre class="literal-block">
class torrent_info
{
   explicit <strong>torrent_info</strong> (sha1_hash const&amp; info_hash);
   <strong>torrent_info</strong> (bdecode_node const&amp; torrent_file, load_torrent_limits const&amp; cfg);
   <strong>torrent_info</strong> (torrent_info const&amp; t);
   explicit <strong>torrent_info</strong> (bdecode_node const&amp; torrent_file);
   <strong>torrent_info</strong> (span&lt;char const&gt; buffer, load_torrent_limits const&amp; cfg, from_span_t);
   explicit <strong>torrent_info</strong> (std::string const&amp; filename);
   <strong>torrent_info</strong> (bdecode_node const&amp; torrent_file, error_code&amp; ec);
   <strong>torrent_info</strong> (span&lt;char const&gt; buffer, error_code&amp; ec, from_span_t);
   <strong>torrent_info</strong> (std::string const&amp; filename, error_code&amp; ec);
   <strong>torrent_info</strong> (char const* buffer, int size);
   <strong>torrent_info</strong> (std::string const&amp; filename, load_torrent_limits const&amp; cfg);
   explicit <strong>torrent_info</strong> (span&lt;char const&gt; buffer, from_span_t);
   <strong>torrent_info</strong> (char const* buffer, int size, error_code&amp; ec);
   <strong>~torrent_info</strong> ();
   file_storage const&amp; <strong>files</strong> () const;
   file_storage const&amp; <strong>orig_files</strong> () const;
   void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename);
   void <strong>remap_files</strong> (file_storage const&amp; f);
   void <strong>add_tracker</strong> (std::string const&amp; url, int tier
      , announce_entry::tracker_source source);
   void <strong>add_tracker</strong> (std::string const&amp; url, int tier = 0);
   std::vector&lt;announce_entry&gt; const&amp; <strong>trackers</strong> () const;
   std::vector&lt;sha1_hash&gt; <strong>similar_torrents</strong> () const;
   std::vector&lt;std::string&gt; <strong>collections</strong> () const;
   void <strong>add_http_seed</strong> (std::string const&amp; url
      , std::string const&amp; extern_auth = std::string()
      , web_seed_entry::headers_t const&amp; extra_headers = web_seed_entry::headers_t());
   std::vector&lt;web_seed_entry&gt; const&amp; <strong>web_seeds</strong> () const;
   void <strong>set_web_seeds</strong> (std::vector&lt;web_seed_entry&gt; seeds);
   void <strong>add_url_seed</strong> (std::string const&amp; url
      , std::string const&amp; extern_auth = std::string()
      , web_seed_entry::headers_t const&amp; extra_headers = web_seed_entry::headers_t());
   int <strong>num_pieces</strong> () const;
   int <strong>piece_length</strong> () const;
   std::int64_t <strong>total_size</strong> () const;
   piece_index_t <strong>last_piece</strong> () const;
   index_range&lt;piece_index_t&gt; <strong>piece_range</strong> () const;
   piece_index_t <strong>end_piece</strong> () const;
   const sha1_hash&amp; <strong>info_hash</strong> () const;
   int <strong>num_files</strong> () const;
   std::vector&lt;file_slice&gt; <strong>map_block</strong> (piece_index_t const piece
      , std::int64_t offset, int size) const;
   peer_request <strong>map_file</strong> (file_index_t const file, std::int64_t offset, int size) const;
   string_view <strong>ssl_cert</strong> () const;
   bool <strong>is_valid</strong> () const;
   bool <strong>priv</strong> () const;
   bool <strong>is_i2p</strong> () const;
   int <strong>piece_size</strong> (piece_index_t index) const;
   sha1_hash <strong>hash_for_piece</strong> (piece_index_t index) const;
   char const* <strong>hash_for_piece_ptr</strong> (piece_index_t const index) const;
   bool <strong>is_loaded</strong> () const;
   std::vector&lt;sha1_hash&gt; const&amp; <strong>merkle_tree</strong> () const;
   void <strong>set_merkle_tree</strong> (std::vector&lt;sha1_hash&gt;&amp; h);
   const std::string&amp; <strong>name</strong> () const;
   std::time_t <strong>creation_date</strong> () const;
   const std::string&amp; <strong>creator</strong> () const;
   const std::string&amp; <strong>comment</strong> () const;
   std::vector&lt;std::pair&lt;std::string, int&gt;&gt; const&amp; <strong>nodes</strong> () const;
   void <strong>add_node</strong> (std::pair&lt;std::string, int&gt; const&amp; node);
   bool <strong>parse_info_section</strong> (bdecode_node const&amp; e, error_code&amp; ec);
   bool <strong>parse_info_section</strong> (bdecode_node const&amp; e, error_code&amp; ec, int piece_limit);
   bdecode_node <strong>info</strong> (char const* key) const;
   void <strong>swap</strong> (torrent_info&amp; ti);
   boost::shared_array&lt;char&gt; <strong>metadata</strong> () const;
   int <strong>metadata_size</strong> () const;
   bool <strong>is_merkle_torrent</strong> () const;
};
</pre>
<a name="torrent_info()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Btorrent_info%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Btorrent_info%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="id143">
<h3>torrent_info()</h3>
<pre class="literal-block">
explicit <strong>torrent_info</strong> (sha1_hash const&amp; info_hash);
<strong>torrent_info</strong> (bdecode_node const&amp; torrent_file, load_torrent_limits const&amp; cfg);
<strong>torrent_info</strong> (torrent_info const&amp; t);
explicit <strong>torrent_info</strong> (bdecode_node const&amp; torrent_file);
<strong>torrent_info</strong> (span&lt;char const&gt; buffer, load_torrent_limits const&amp; cfg, from_span_t);
explicit <strong>torrent_info</strong> (std::string const&amp; filename);
<strong>torrent_info</strong> (bdecode_node const&amp; torrent_file, error_code&amp; ec);
<strong>torrent_info</strong> (span&lt;char const&gt; buffer, error_code&amp; ec, from_span_t);
<strong>torrent_info</strong> (std::string const&amp; filename, error_code&amp; ec);
<strong>torrent_info</strong> (char const* buffer, int size);
<strong>torrent_info</strong> (std::string const&amp; filename, load_torrent_limits const&amp; cfg);
explicit <strong>torrent_info</strong> (span&lt;char const&gt; buffer, from_span_t);
<strong>torrent_info</strong> (char const* buffer, int size, error_code&amp; ec);
</pre>
<p>The constructor that takes an info-hash  will initialize the info-hash
to the given value, but leave all other fields empty. This is used
internally when downloading torrents without the metadata. The
metadata will be created by libtorrent as soon as it has been
downloaded from the swarm.</p>
<p>The constructor that takes a <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a> will create a <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a>
object from the information found in the given torrent_file. The
<a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a> represents a tree node in an bencoded file. To load an
ordinary .torrent file into a <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a>, use <a class="reference external" href="reference-Bdecoding.html#bdecode()">bdecode()</a>.</p>
<p>The version that takes a buffer pointer and a size will decode it as a
.torrent file and initialize the <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object for you.</p>
<p>The version that takes a filename will simply load the torrent file
and decode it inside the constructor, for convenience. This might not
be the most suitable for applications that want to be able to report
detailed errors on what might go wrong.</p>
<p>There is an upper limit on the size of the torrent file that will be
loaded by the overload taking a filename. If it's important that even
very large torrent files are loaded, use one of the other overloads.</p>
<p>The overloads that takes an <tt class="docutils literal">error_code const&amp;</tt> never throws if an
error occur, they will simply set the error code to describe what went
wrong and not fully initialize the <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object. The overloads
that do not take the extra error_code parameter will always throw if
an error occurs. These overloads are not available when building
without exception support.</p>
<p>The overload that takes a <tt class="docutils literal">span</tt> also needs an extra parameter of
type <tt class="docutils literal">from_span_t</tt> to disambiguate the <tt class="docutils literal"><span class="pre">std::string</span></tt> overload for
string literals. There is an object in the libtorrent namespace of this
type called <tt class="docutils literal">from_span</tt>.</p>
<a name="~torrent_info()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5B~torrent_info%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5B~torrent_info%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="id151">
<h3>~torrent_info()</h3>
<pre class="literal-block">
<strong>~torrent_info</strong> ();
</pre>
<p>frees all storage associated with this <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object</p>
<a name="files()"></a>
<a name="orig_files()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bfiles%28%29+orig_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bfiles%28%29+orig_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="files-orig-files">
<h3>files() orig_files()</h3>
<pre class="literal-block">
file_storage const&amp; <strong>files</strong> () const;
file_storage const&amp; <strong>orig_files</strong> () const;
</pre>
<p>The <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object contains the information on how to map the
pieces to files. It is separated from the <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object because
when creating torrents a storage object needs to be created without
having a torrent file. When renaming files in a storage, the storage
needs to make its own copy of the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> in order to make its
mapping differ from the one in the torrent file.</p>
<p><tt class="docutils literal">orig_files()</tt> returns the original (unmodified) file storage for
this torrent. This is used by the web server connection, which needs
to request files with the original names. Filename may be changed using
<tt class="docutils literal"><span class="pre">torrent_info::rename_file()</span></tt>.</p>
<p>For more information on the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a> object, see the separate
document on how to create torrents.</p>
<a name="rename_file()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Brename_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Brename_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="id157">
<h3>rename_file()</h3>
<pre class="literal-block">
void <strong>rename_file</strong> (file_index_t index, std::string const&amp; new_filename);
</pre>
<p>Renames the file with the specified index to the new name. The new
filename is reflected by the <tt class="docutils literal">file_storage</tt> returned by <tt class="docutils literal">files()</tt>
but not by the one returned by <tt class="docutils literal">orig_files()</tt>.</p>
<p>If you want to rename the base name of the torrent (for a multi file
torrent), you can copy the <tt class="docutils literal">file_storage</tt> (see <a class="reference external" href="reference-Core.html#files()">files()</a> and
<a class="reference external" href="reference-Core.html#orig_files()">orig_files()</a> ), change the name, and then use <a class="reference internal" href="#remap-files">remap_files()</a>.</p>
<p>The <tt class="docutils literal">new_filename</tt> can both be a relative path, in which case the
file name is relative to the <tt class="docutils literal">save_path</tt> of the torrent. If the
<tt class="docutils literal">new_filename</tt> is an absolute path (i.e. <tt class="docutils literal">is_complete(new_filename)
== true</tt>), then the file is detached from the <tt class="docutils literal">save_path</tt> of the
torrent. In this case the file is not moved when <a class="reference external" href="reference-Core.html#move_storage()">move_storage()</a> is
invoked.</p>
<a name="remap_files()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bremap_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bremap_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="remap-files">
<h3>remap_files()</h3>
<pre class="literal-block">
void <strong>remap_files</strong> (file_storage const&amp; f);
</pre>
<p>Remaps the file storage to a new file layout. This can be used to, for
instance, download all data in a torrent to a single file, or to a
number of fixed size sector aligned files, regardless of the number
and sizes of the files in the torrent.</p>
<p>The new specified <tt class="docutils literal">file_storage</tt> must have the exact same size as
the current one.</p>
<a name="add_tracker()"></a>
<a name="trackers()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Badd_tracker%28%29+trackers%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Badd_tracker%28%29+trackers%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-tracker-trackers">
<h3>add_tracker() trackers()</h3>
<pre class="literal-block">
void <strong>add_tracker</strong> (std::string const&amp; url, int tier
      , announce_entry::tracker_source source);
void <strong>add_tracker</strong> (std::string const&amp; url, int tier = 0);
std::vector&lt;announce_entry&gt; const&amp; <strong>trackers</strong> () const;
</pre>
<p><tt class="docutils literal">add_tracker()</tt> adds a tracker to the announce-list. The <tt class="docutils literal">tier</tt>
determines the order in which the trackers are to be tried.
The <tt class="docutils literal">trackers()</tt> function will return a sorted vector of
<tt class="docutils literal">announce_entry</tt>. Each announce <a class="reference external" href="reference-Bencoding.html#entry">entry</a> contains a string, which is
the tracker url, and a tier index. The tier index is the high-level
priority. No matter which trackers that works or not, the ones with
lower tier will always be tried before the one with higher tier
number. For more information, see <a class="reference internal" href="#announce-entry">announce_entry</a>.</p>
<a name="similar_torrents()"></a>
<a name="collections()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bsimilar_torrents%28%29+collections%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bsimilar_torrents%28%29+collections%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="similar-torrents-collections">
<h3>similar_torrents() collections()</h3>
<pre class="literal-block">
std::vector&lt;sha1_hash&gt; <strong>similar_torrents</strong> () const;
std::vector&lt;std::string&gt; <strong>collections</strong> () const;
</pre>
<p>These two functions are related to <a class="reference external" href="http://www.bittorrent.org/beps/bep_0038.html">BEP 38</a> (mutable torrents). The
vectors returned from these correspond to the &quot;similar&quot; and
&quot;collections&quot; keys in the .torrent file. Both info-hashes and
collections from within the info-dict and from outside of it are
included.</p>
<a name="add_http_seed()"></a>
<a name="web_seeds()"></a>
<a name="add_url_seed()"></a>
<a name="set_web_seeds()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Badd_http_seed%28%29+web_seeds%28%29+add_url_seed%28%29+set_web_seeds%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Badd_http_seed%28%29+web_seeds%28%29+add_url_seed%28%29+set_web_seeds%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-http-seed-web-seeds-add-url-seed-set-web-seeds">
<h3>add_http_seed() web_seeds() add_url_seed() set_web_seeds()</h3>
<pre class="literal-block">
void <strong>add_http_seed</strong> (std::string const&amp; url
      , std::string const&amp; extern_auth = std::string()
      , web_seed_entry::headers_t const&amp; extra_headers = web_seed_entry::headers_t());
std::vector&lt;web_seed_entry&gt; const&amp; <strong>web_seeds</strong> () const;
void <strong>set_web_seeds</strong> (std::vector&lt;web_seed_entry&gt; seeds);
void <strong>add_url_seed</strong> (std::string const&amp; url
      , std::string const&amp; extern_auth = std::string()
      , web_seed_entry::headers_t const&amp; extra_headers = web_seed_entry::headers_t());
</pre>
<p><tt class="docutils literal">web_seeds()</tt> returns all url seeds and http seeds in the torrent.
Each <a class="reference external" href="reference-Bencoding.html#entry">entry</a> is a <tt class="docutils literal">web_seed_entry</tt> and may refer to either a url seed
or http seed.</p>
<p><tt class="docutils literal">add_url_seed()</tt> and <tt class="docutils literal">add_http_seed()</tt> adds one url to the list of
url/http seeds. Currently, the only transport protocol supported for
the url is http.</p>
<p><tt class="docutils literal">set_web_seeds()</tt> replaces all web seeds with the ones specified in
the <tt class="docutils literal">seeds</tt> vector.</p>
<p>The <tt class="docutils literal">extern_auth</tt> argument can be used for other authorization
schemes than basic HTTP authorization. If set, it will override any
username and password found in the URL itself. The string will be sent
as the HTTP authorization header's value (without specifying &quot;Basic&quot;).</p>
<p>The <tt class="docutils literal">extra_headers</tt> argument defaults to an empty list, but can be
used to insert custom HTTP headers in the requests to a specific web
seed.</p>
<p>See <a class="reference external" href="manual-ref.html#http-seeding">http seeding</a> for more information.</p>
<a name="total_size()"></a>
<a name="piece_length()"></a>
<a name="num_pieces()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Btotal_size%28%29+piece_length%28%29+num_pieces%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Btotal_size%28%29+piece_length%28%29+num_pieces%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="total-size-piece-length-num-pieces">
<h3>total_size() piece_length() num_pieces()</h3>
<pre class="literal-block">
int <strong>num_pieces</strong> () const;
int <strong>piece_length</strong> () const;
std::int64_t <strong>total_size</strong> () const;
</pre>
<p><tt class="docutils literal">total_size()</tt>, <tt class="docutils literal">piece_length()</tt> and <tt class="docutils literal">num_pieces()</tt> returns the
total number of bytes the torrent-file represents (all the files in
it), the number of byte for each piece and the total number of pieces,
respectively. The difference between <tt class="docutils literal">piece_size()</tt> and
<tt class="docutils literal">piece_length()</tt> is that <tt class="docutils literal">piece_size()</tt> takes the piece index as
argument and gives you the exact size of that piece. It will always be
the same as <tt class="docutils literal">piece_length()</tt> except in the case of the last piece,
which may be smaller.</p>
<a name="piece_range()"></a>
<a name="end_piece()"></a>
<a name="last_piece()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bpiece_range%28%29+end_piece%28%29+last_piece%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bpiece_range%28%29+end_piece%28%29+last_piece%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-range-end-piece-last-piece">
<h3>piece_range() end_piece() last_piece()</h3>
<pre class="literal-block">
piece_index_t <strong>last_piece</strong> () const;
index_range&lt;piece_index_t&gt; <strong>piece_range</strong> () const;
piece_index_t <strong>end_piece</strong> () const;
</pre>
<p><tt class="docutils literal">last_piece()</tt> returns the index to the last piece in the torrent and
<tt class="docutils literal">end_piece()</tt> returns the index to the one-past-end piece in the
torrent
<tt class="docutils literal">piece_range()</tt> returns an implementation-defined type that can be
used as the container in a range-for loop. Where the values are the
indices of all pieces in the <a class="reference external" href="reference-Storage.html#file_storage">file_storage</a>.</p>
<a name="info_hash()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Binfo_hash%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Binfo_hash%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="id165">
<h3>info_hash()</h3>
<pre class="literal-block">
const sha1_hash&amp; <strong>info_hash</strong> () const;
</pre>
<p>returns the info-hash of the torrent</p>
<a name="num_files()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bnum_files%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bnum_files%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="num-files">
<h3>num_files()</h3>
<pre class="literal-block">
int <strong>num_files</strong> () const;
</pre>
<p>If you need index-access to files you can use the <tt class="docutils literal">num_files()</tt> along
with the <tt class="docutils literal">file_path()</tt>, <tt class="docutils literal">file_size()</tt>-family of functions to access
files using indices.</p>
<a name="map_block()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bmap_block%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bmap_block%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="map-block">
<h3>map_block()</h3>
<pre class="literal-block">
std::vector&lt;file_slice&gt; <strong>map_block</strong> (piece_index_t const piece
      , std::int64_t offset, int size) const;
</pre>
<p>This function will map a piece index, a byte offset within that piece
and a size (in bytes) into the corresponding files with offsets where
that data for that piece is supposed to be stored. See <a class="reference external" href="reference-Storage.html#file_slice">file_slice</a>.</p>
<a name="map_file()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bmap_file%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bmap_file%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="map-file">
<h3>map_file()</h3>
<pre class="literal-block">
peer_request <strong>map_file</strong> (file_index_t const file, std::int64_t offset, int size) const;
</pre>
<p>This function will map a range in a specific file into a range in the
torrent. The <tt class="docutils literal">file_offset</tt> parameter is the offset in the file,
given in bytes, where 0 is the start of the file. See <a class="reference external" href="reference-Core.html#peer_request">peer_request</a>.</p>
<p>The input range is assumed to be valid within the torrent.
<tt class="docutils literal">file_offset</tt> + <tt class="docutils literal">size</tt> is not allowed to be greater than the file
size. <tt class="docutils literal">file_index</tt> must refer to a valid file, i.e. it cannot be &gt;=
<tt class="docutils literal">num_files()</tt>.</p>
<a name="ssl_cert()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bssl_cert%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bssl_cert%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="ssl-cert">
<h3>ssl_cert()</h3>
<pre class="literal-block">
string_view <strong>ssl_cert</strong> () const;
</pre>
<p>Returns the SSL root certificate for the torrent, if it is an SSL
torrent. Otherwise returns an empty string. The certificate is
the public certificate in x509 format.</p>
<a name="is_valid()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bis_valid%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bis_valid%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="id168">
<h3>is_valid()</h3>
<pre class="literal-block">
bool <strong>is_valid</strong> () const;
</pre>
<p>returns true if this <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object has a torrent loaded.
This is primarily used to determine if a magnet link has had its
metadata resolved yet or not.</p>
<a name="priv()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bpriv%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bpriv%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="priv">
<h3>priv()</h3>
<pre class="literal-block">
bool <strong>priv</strong> () const;
</pre>
<p>returns true if this torrent is private. i.e., the client should not
advertise itself on the trackerless network (the Kademlia DHT) for this torrent.</p>
<a name="is_i2p()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bis_i2p%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bis_i2p%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-i2p">
<h3>is_i2p()</h3>
<pre class="literal-block">
bool <strong>is_i2p</strong> () const;
</pre>
<p>returns true if this is an i2p torrent. This is determined by whether
or not it has a tracker whose URL domain name ends with &quot;.i2p&quot;. i2p
torrents disable the DHT and local peer discovery as well as talking
to peers over anything other than the i2p network.</p>
<a name="piece_size()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bpiece_size%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bpiece_size%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="piece-size">
<h3>piece_size()</h3>
<pre class="literal-block">
int <strong>piece_size</strong> (piece_index_t index) const;
</pre>
<p>returns the piece size of file with <tt class="docutils literal">index</tt>. This will be the same as <a class="reference external" href="reference-Storage.html#piece_length()">piece_length()</a>,
except for the last piece, which may be shorter.</p>
<a name="hash_for_piece()"></a>
<a name="hash_for_piece_ptr()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bhash_for_piece%28%29+hash_for_piece_ptr%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bhash_for_piece%28%29+hash_for_piece_ptr%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="hash-for-piece-hash-for-piece-ptr">
<h3>hash_for_piece() hash_for_piece_ptr()</h3>
<pre class="literal-block">
sha1_hash <strong>hash_for_piece</strong> (piece_index_t index) const;
char const* <strong>hash_for_piece_ptr</strong> (piece_index_t const index) const;
</pre>
<p><tt class="docutils literal">hash_for_piece()</tt> takes a piece-index and returns the 20-bytes
sha1-hash for that piece and <tt class="docutils literal">info_hash()</tt> returns the 20-bytes
sha1-hash for the info-section of the torrent file.
<tt class="docutils literal">hash_for_piece_ptr()</tt> returns a pointer to the 20 byte sha1 digest
for the piece. Note that the string is not 0-terminated.</p>
<a name="merkle_tree()"></a>
<a name="set_merkle_tree()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bmerkle_tree%28%29+set_merkle_tree%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bmerkle_tree%28%29+set_merkle_tree%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="merkle-tree-set-merkle-tree">
<h3>merkle_tree() set_merkle_tree()</h3>
<pre class="literal-block">
std::vector&lt;sha1_hash&gt; const&amp; <strong>merkle_tree</strong> () const;
void <strong>set_merkle_tree</strong> (std::vector&lt;sha1_hash&gt;&amp; h);
</pre>
<p><tt class="docutils literal">merkle_tree()</tt> returns a reference to the merkle tree for this
torrent, if any.
<tt class="docutils literal">set_merkle_tree()</tt> moves the passed in merkle tree into the
<a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object. i.e. <tt class="docutils literal">h</tt> will not be identical after the call.
You need to set the merkle tree for a torrent that you've just created
(as a merkle torrent). The merkle tree is retrieved from the
<tt class="docutils literal"><span class="pre">create_torrent::merkle_tree()</span></tt> function, and need to be saved
separately from the torrent file itself. Once it's added to
libtorrent, the merkle tree will be persisted in the resume data.</p>
<a name="name()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bname%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bname%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="name">
<h3>name()</h3>
<pre class="literal-block">
const std::string&amp; <strong>name</strong> () const;
</pre>
<p><tt class="docutils literal">name()</tt> returns the name of the torrent.
name contains UTF-8 encoded string.</p>
<a name="creation_date()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bcreation_date%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bcreation_date%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="creation-date">
<h3>creation_date()</h3>
<pre class="literal-block">
std::time_t <strong>creation_date</strong> () const;
</pre>
<p><tt class="docutils literal">creation_date()</tt> returns the creation date of the torrent as time_t
(<a class="reference internal" href="#posix-time">posix time</a>). If there's no time stamp in the torrent file, the
optional object will be uninitialized.
.. <span class="target" id="posix-time">posix time</span>: <a class="reference external" href="http://www.opengroup.org/onlinepubs/009695399/functions/time.html">http://www.opengroup.org/onlinepubs/009695399/functions/time.html</a></p>
<a name="creator()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bcreator%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bcreator%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="creator">
<h3>creator()</h3>
<pre class="literal-block">
const std::string&amp; <strong>creator</strong> () const;
</pre>
<p><tt class="docutils literal">creator()</tt> returns the creator string in the torrent. If there is
no creator string it will return an empty string.</p>
<a name="comment()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bcomment%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bcomment%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="comment">
<h3>comment()</h3>
<pre class="literal-block">
const std::string&amp; <strong>comment</strong> () const;
</pre>
<p><tt class="docutils literal">comment()</tt> returns the comment associated with the torrent. If
there's no comment, it will return an empty string.
comment contains UTF-8 encoded string.</p>
<a name="nodes()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bnodes%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bnodes%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="nodes">
<h3>nodes()</h3>
<pre class="literal-block">
std::vector&lt;std::pair&lt;std::string, int&gt;&gt; const&amp; <strong>nodes</strong> () const;
</pre>
<p>If this torrent contains any DHT nodes, they are put in this vector in
their original form (host name and port number).</p>
<a name="add_node()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Badd_node%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Badd_node%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="add-node">
<h3>add_node()</h3>
<pre class="literal-block">
void <strong>add_node</strong> (std::pair&lt;std::string, int&gt; const&amp; node);
</pre>
<p>This is used when creating torrent. Use this to add a known DHT node.
It may be used, by the client, to bootstrap into the DHT network.</p>
<a name="parse_info_section()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bparse_info_section%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bparse_info_section%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="parse-info-section">
<h3>parse_info_section()</h3>
<pre class="literal-block">
bool <strong>parse_info_section</strong> (bdecode_node const&amp; e, error_code&amp; ec);
bool <strong>parse_info_section</strong> (bdecode_node const&amp; e, error_code&amp; ec, int piece_limit);
</pre>
<p>populates the <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> by providing just the info-dict buffer.
This is used when loading a torrent from a magnet link for instance,
where we only have the info-dict. The <a class="reference external" href="reference-Bdecoding.html#bdecode_node">bdecode_node</a> <tt class="docutils literal">e</tt> points to a
parsed info-dictionary. <tt class="docutils literal">ec</tt> returns an error code if something
fails (typically if the info dictionary is malformed).
the <cite>piece_limit</cite> parameter allows limiting the amount of memory
dedicated to loading the torrent, and fails for torrents that exceed
the limit</p>
<a name="info()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Binfo%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Binfo%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="info">
<h3>info()</h3>
<pre class="literal-block">
bdecode_node <strong>info</strong> (char const* key) const;
</pre>
<p>This function looks up keys from the info-dictionary of the loaded
torrent file. It can be used to access extension values put in the
.torrent file. If the specified key cannot be found, it returns nullptr.</p>
<a name="swap()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bswap%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bswap%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="swap">
<h3>swap()</h3>
<pre class="literal-block">
void <strong>swap</strong> (torrent_info&amp; ti);
</pre>
<p>swap the content of this and <tt class="docutils literal">ti</tt>.</p>
<a name="metadata_size()"></a>
<a name="metadata()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bmetadata_size%28%29+metadata%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bmetadata_size%28%29+metadata%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="metadata-size-metadata">
<h3>metadata_size() metadata()</h3>
<pre class="literal-block">
boost::shared_array&lt;char&gt; <strong>metadata</strong> () const;
int <strong>metadata_size</strong> () const;
</pre>
<p><tt class="docutils literal">metadata()</tt> returns a the raw info section of the torrent file. The size
of the metadata is returned by <tt class="docutils literal">metadata_size()</tt>.</p>
<a name="is_merkle_torrent()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_info%3A%3A%5Bis_merkle_torrent%28%29%5D&labels=documentation&body=Documentation+under+heading+%22torrent_info%3A%3A%5Bis_merkle_torrent%28%29%5D%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-merkle-torrent">
<h3>is_merkle_torrent()</h3>
<pre class="literal-block">
bool <strong>is_merkle_torrent</strong> () const;
</pre>
<p>returns whether or not this is a merkle torrent.
see <a class="reference external" href="https://www.bittorrent.org/beps/bep_0030.html">BEP 30</a>.</p>
<a name="add_torrent_params"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+add_torrent_params&labels=documentation&body=Documentation+under+heading+%22class+add_torrent_params%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="add-torrent-params">
<h2>add_torrent_params</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/add_torrent_params.hpp">libtorrent/add_torrent_params.hpp</a>&quot;</p>
<p>The <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> is a parameter pack for adding torrents to a
<a class="reference external" href="reference-Session.html#session">session</a>. The key fields when adding a torrent are:</p>
<ul class="simple">
<li>ti - when you have loaded a .torrent file into a <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object</li>
<li>info_hash - when you don't have the metadata (.torrent file) but. This
is set when adding a magnet link.</li>
</ul>
<p>one of those fields must be set. Another mandatory field is
<tt class="docutils literal">save_path</tt>. The <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> object is passed into one of the
<tt class="docutils literal"><span class="pre">session::add_torrent()</span></tt> overloads or <tt class="docutils literal"><span class="pre">session::async_add_torrent()</span></tt>.</p>
<p>If you only specify the info-hash, the torrent file will be downloaded
from peers, which requires them to support the metadata extension. For
the metadata extension to work, libtorrent must be built with extensions
enabled (<tt class="docutils literal">TORRENT_DISABLE_EXTENSIONS</tt> must not be defined). It also
takes an optional <tt class="docutils literal">name</tt> argument. This may be left empty in case no
name should be assigned to the torrent. In case it's not, the name is
used for the torrent as long as it doesn't have metadata. See
<tt class="docutils literal"><span class="pre">torrent_handle::name</span></tt>.</p>
<p>The <tt class="docutils literal">add_torrent_params</tt> is also used when requesting resume data for a
torrent. It can be saved to and restored from a file and added back to a
new <a class="reference external" href="reference-Session.html#session">session</a>. For serialization and de-serialization of
<tt class="docutils literal">add_torrent_params</tt> objects, see <a class="reference external" href="reference-Core.html#read_resume_data()">read_resume_data()</a> and
<a class="reference external" href="reference-Core.html#write_resume_data()">write_resume_data()</a>.</p>
<pre class="literal-block">
struct add_torrent_params
{
   add_torrent_params&amp; <strong>operator=</strong> (add_torrent_params&amp;&amp;) = default;
   <strong>add_torrent_params</strong> (add_torrent_params const&amp;);
   explicit <strong>add_torrent_params</strong> (storage_constructor_type sc = default_storage_constructor);
   add_torrent_params&amp; <strong>operator=</strong> (add_torrent_params const&amp;);
   <strong>add_torrent_params</strong> (add_torrent_params&amp;&amp;) noexcept;

   int <strong>version</strong>  = LIBTORRENT_VERSION_NUM;
   std::shared_ptr&lt;torrent_info&gt; ti;
   aux::noexcept_movable&lt;std::vector&lt;std::string&gt;&gt; trackers;
   aux::noexcept_movable&lt;std::vector&lt;int&gt;&gt; tracker_tiers;
   aux::noexcept_movable&lt;std::vector&lt;std::pair&lt;std::string, int&gt;&gt;&gt; dht_nodes;
   std::string name;
   std::string save_path;
   storage_mode_t <strong>storage_mode</strong>  = storage_mode_sparse;
   aux::noexcept_movable&lt;storage_constructor_type&gt; storage;
   void* <strong>userdata</strong>  = nullptr;
   aux::noexcept_movable&lt;std::vector&lt;download_priority_t&gt;&gt; file_priorities;
   std::string trackerid;
   torrent_flags_t <strong>flags</strong>  = torrent_flags::default_flags;
   sha1_hash info_hash;
   int <strong>max_uploads</strong>  = -1;
   int <strong>max_connections</strong>  = -1;
   int <strong>upload_limit</strong>  = -1;
   int <strong>download_limit</strong>  = -1;
   std::int64_t <strong>total_uploaded</strong>  = 0;
   std::int64_t <strong>total_downloaded</strong>  = 0;
   int <strong>active_time</strong>  = 0;
   int <strong>finished_time</strong>  = 0;
   int <strong>seeding_time</strong>  = 0;
   std::time_t <strong>added_time</strong>  = 0;
   std::time_t <strong>completed_time</strong>  = 0;
   std::time_t <strong>last_seen_complete</strong>  = 0;
   int <strong>num_complete</strong>  = -1;
   int <strong>num_incomplete</strong>  = -1;
   int <strong>num_downloaded</strong>  = -1;
   aux::noexcept_movable&lt;std::vector&lt;std::string&gt;&gt; http_seeds;
   aux::noexcept_movable&lt;std::vector&lt;std::string&gt;&gt; url_seeds;
   aux::noexcept_movable&lt;std::vector&lt;tcp::endpoint&gt;&gt; peers;
   aux::noexcept_movable&lt;std::vector&lt;tcp::endpoint&gt;&gt; banned_peers;
   aux::noexcept_movable&lt;std::map&lt;piece_index_t, bitfield&gt;&gt; unfinished_pieces;
   typed_bitfield&lt;piece_index_t&gt; have_pieces;
   typed_bitfield&lt;piece_index_t&gt; verified_pieces;
   aux::noexcept_movable&lt;std::vector&lt;download_priority_t&gt;&gt; piece_priorities;
   aux::noexcept_movable&lt;std::vector&lt;sha1_hash&gt;&gt; merkle_tree;
   aux::noexcept_movable&lt;std::map&lt;file_index_t, std::string&gt;&gt; renamed_files;
   std::time_t <strong>last_download</strong>  = 0;
   std::time_t <strong>last_upload</strong>  = 0;
};
</pre>
<a name="operator=()"></a>
<a name="add_torrent_params()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Boperator%3D%28%29+add_torrent_params%28%29%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Boperator%3D%28%29+add_torrent_params%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="operator-add-torrent-params">
<h3>operator=() add_torrent_params()</h3>
<pre class="literal-block">
add_torrent_params&amp; <strong>operator=</strong> (add_torrent_params&amp;&amp;) = default;
<strong>add_torrent_params</strong> (add_torrent_params const&amp;);
explicit <strong>add_torrent_params</strong> (storage_constructor_type sc = default_storage_constructor);
add_torrent_params&amp; <strong>operator=</strong> (add_torrent_params const&amp;);
<strong>add_torrent_params</strong> (add_torrent_params&amp;&amp;) noexcept;
</pre>
<p>The constructor can be used to initialize the storage constructor,
which determines the storage mechanism for the downloaded or seeding
data for the torrent. For more information, see the <tt class="docutils literal">storage</tt> field.</p>
<a name="version"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bversion%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bversion%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>version</dt>
<dd>filled in by the constructor and should be left untouched. It is used
for forward binary compatibility.</dd>
</dl>
<a name="ti"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bti%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bti%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ti</dt>
<dd><a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object with the torrent to add. Unless the
info_hash is set, this is required to be initialized.</dd>
</dl>
<a name="trackers"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Btrackers%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Btrackers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>trackers</dt>
<dd>If the torrent doesn't have a tracker, but relies on the DHT to find
peers, the <tt class="docutils literal">trackers</tt> can specify tracker URLs for the torrent.</dd>
</dl>
<a name="tracker_tiers"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Btracker_tiers%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Btracker_tiers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>tracker_tiers</dt>
<dd>the tiers the URLs in <tt class="docutils literal">trackers</tt> belong to. Trackers belonging to
different tiers may be treated differently, as defined by the multi
tracker extension. This is optional, if not specified trackers are
assumed to be part of tier 0, or whichever the last tier was as
iterating over the trackers.</dd>
</dl>
<a name="dht_nodes"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bdht_nodes%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bdht_nodes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>dht_nodes</dt>
<dd>a list of hostname and port pairs, representing DHT nodes to be added
to the <a class="reference external" href="reference-Session.html#session">session</a> (if DHT is enabled). The hostname may be an IP address.</dd>
</dl>
<a name="name"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bname%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bname%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>name</dt>
<dd>in case there's no other name in this torrent, this name will be used.
The name out of the <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object takes precedence if available.</dd>
</dl>
<a name="save_path"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bsave_path%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bsave_path%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>save_path</dt>
<dd><p class="first">the path where the torrent is or will be stored.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">On windows this path (and other paths) are interpreted as UNC
paths. This means they must use backslashes as directory separators
and may not contain the special directories &quot;.&quot; or &quot;..&quot;.</p>
</div>
<p class="last">Setting this to an absolute path performs slightly better than a
relative path.</p>
</dd>
</dl>
<a name="storage_mode"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bstorage_mode%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bstorage_mode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>storage_mode</dt>
<dd>One of the values from <a class="reference external" href="reference-Storage.html#storage_mode_t">storage_mode_t</a>. For more information, see
<a class="reference external" href="manual-ref.html#storage-allocation">storage allocation</a>.</dd>
</dl>
<a name="storage"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bstorage%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bstorage%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>storage</dt>
<dd>can be used to customize how the data is stored. The default storage
will simply write the data to the files it belongs to, but it could be
overridden to save everything to a single file at a specific location
or encrypt the content on disk for instance. For more information
about the <a class="reference external" href="reference-Custom_Storage.html#storage_interface">storage_interface</a> that needs to be implemented for a custom
storage, see <a class="reference external" href="reference-Custom_Storage.html#storage_interface">storage_interface</a>.</dd>
</dl>
<a name="userdata"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Buserdata%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Buserdata%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>userdata</dt>
<dd>The <tt class="docutils literal">userdata</tt> parameter is optional and will be passed on to the
extension constructor functions, if any
(see <a class="reference external" href="reference-Core.html#add_extension()">torrent_handle::add_extension()</a>).</dd>
</dl>
<a name="file_priorities"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bfile_priorities%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bfile_priorities%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>file_priorities</dt>
<dd>can be set to control the initial file priorities when adding a
torrent. The semantics are the same as for
<tt class="docutils literal"><span class="pre">torrent_handle::prioritize_files()</span></tt>. The file priorities specified
in here take precedence over those specified in the resume data, if
any.</dd>
</dl>
<a name="trackerid"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Btrackerid%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Btrackerid%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>trackerid</dt>
<dd>the default tracker id to be used when announcing to trackers. By
default this is empty, and no tracker ID is used, since this is an
optional argument. If a tracker returns a tracker ID, that ID is used
instead of this.</dd>
</dl>
<a name="flags"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bflags%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bflags%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flags</dt>
<dd><p class="first">flags controlling aspects of this torrent and how it's added. See
<a class="reference external" href="reference-Core.html#torrent_flags_t">torrent_flags_t</a> for details.</p>
<div class="admonition note last">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal">flags</tt> field is initialized with default flags by the
constructor. In order to preserve default behavior when clearing or
setting other flags, make sure to bitwise OR or in a flag or bitwise
AND the inverse of a flag to clear it.</p>
</div>
</dd>
</dl>
<a name="info_hash"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Binfo_hash%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Binfo_hash%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>info_hash</dt>
<dd>set this to the info hash of the torrent to add in case the info-hash
is the only known property of the torrent. i.e. you don't have a
.torrent file nor a magnet link.
To add a magnet link, use <a class="reference external" href="reference-Core.html#parse_magnet_uri()">parse_magnet_uri()</a> to populate fields in the
<a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> object.</dd>
</dl>
<a name="max_uploads"></a>
<a name="max_connections"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bmax_uploads+max_connections%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bmax_uploads+max_connections%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>max_uploads max_connections</dt>
<dd><p class="first"><tt class="docutils literal">max_uploads</tt>, <tt class="docutils literal">max_connections</tt>, <tt class="docutils literal">upload_limit</tt>,
<tt class="docutils literal">download_limit</tt> correspond to the <tt class="docutils literal">set_max_uploads()</tt>,
<tt class="docutils literal">set_max_connections()</tt>, <tt class="docutils literal">set_upload_limit()</tt> and
<tt class="docutils literal">set_download_limit()</tt> functions on <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a>. These values let
you initialize these settings when the torrent is added, instead of
calling these functions immediately following adding it.</p>
<p>-1 means unlimited on these settings just like their counterpart
functions on <a class="reference external" href="reference-Core.html#torrent_handle">torrent_handle</a></p>
<p class="last">For fine grained control over rate limits, including making them apply
to local peers, see <a class="reference external" href="manual-ref.html#peer-classes">peer classes</a>.</p>
</dd>
</dl>
<a name="upload_limit"></a>
<a name="download_limit"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bupload_limit+download_limit%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bupload_limit+download_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_limit download_limit</dt>
<dd>the upload and download rate limits for this torrent, specified in
bytes per second. -1 means unlimited.</dd>
</dl>
<a name="total_uploaded"></a>
<a name="total_downloaded"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Btotal_uploaded+total_downloaded%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Btotal_uploaded+total_downloaded%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_uploaded total_downloaded</dt>
<dd>the total number of bytes uploaded and downloaded by this torrent so
far.</dd>
</dl>
<a name="active_time"></a>
<a name="finished_time"></a>
<a name="seeding_time"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bactive_time+finished_time+seeding_time%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bactive_time+finished_time+seeding_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>active_time finished_time seeding_time</dt>
<dd>the number of seconds this torrent has spent in started, finished and
seeding state so far, respectively.</dd>
</dl>
<a name="added_time"></a>
<a name="completed_time"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Badded_time+completed_time%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Badded_time+completed_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>added_time completed_time</dt>
<dd>if set to a non-zero value, this is the posix time of when this torrent
was first added, including previous runs/sessions. If set to zero, the
internal added_time will be set to the time of when <a class="reference external" href="reference-Session.html#add_torrent()">add_torrent()</a> is
called.</dd>
</dl>
<a name="last_seen_complete"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Blast_seen_complete%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Blast_seen_complete%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_seen_complete</dt>
<dd>if set to non-zero, initializes the time (expressed in posix time) when
we last saw a seed or peers that together formed a complete copy of the
torrent. If left set to zero, the internal counterpart to this field
will be updated when we see a seed or a distributed copies &gt;= 1.0.</dd>
</dl>
<a name="num_complete"></a>
<a name="num_incomplete"></a>
<a name="num_downloaded"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bnum_complete+num_incomplete+num_downloaded%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bnum_complete+num_incomplete+num_downloaded%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_complete num_incomplete num_downloaded</dt>
<dd><p class="first">these field can be used to initialize the torrent's cached scrape data.
The scrape data is high level metadata about the current state of the
swarm, as returned by the tracker (either when announcing to it or by
sending a specific scrape request). <tt class="docutils literal">num_complete</tt> is the number of
peers in the swarm that are seeds, or have every piece in the torrent.
<tt class="docutils literal">num_incomplete</tt> is the number of peers in the swarm that do not have
every piece. <tt class="docutils literal">num_downloaded</tt> is the number of times the torrent has
been downloaded (not initiated, but the number of times a download has
completed).</p>
<p class="last">Leaving any of these values set to -1 indicates we don't know, or we
have not received any scrape data.</p>
</dd>
</dl>
<a name="http_seeds"></a>
<a name="url_seeds"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bhttp_seeds+url_seeds%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bhttp_seeds+url_seeds%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>http_seeds url_seeds</dt>
<dd><p class="first">URLs can be added to these two lists to specify additional web
seeds to be used by the torrent. If the <tt class="docutils literal">flag_override_web_seeds</tt>
is set, these will be the _only_ ones to be used. i.e. any web seeds
found in the .torrent file will be overridden.</p>
<p>http_seeds expects URLs to web servers implementing the original HTTP
seed specification <a class="reference external" href="https://www.bittorrent.org/beps/bep_0017.html">BEP 17</a>.</p>
<p class="last">url_seeds expects URLs to regular web servers, aka &quot;get right&quot; style,
specified in <a class="reference external" href="https://www.bittorrent.org/beps/bep_0019.html">BEP 19</a>.</p>
</dd>
</dl>
<a name="peers"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bpeers%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bpeers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>peers</dt>
<dd>peers to add to the torrent, to be tried to be connected to as
bittorrent peers.</dd>
</dl>
<a name="banned_peers"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bbanned_peers%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bbanned_peers%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>banned_peers</dt>
<dd>peers banned from this torrent. The will not be connected to</dd>
</dl>
<a name="unfinished_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bunfinished_pieces%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bunfinished_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>unfinished_pieces</dt>
<dd>this is a map of partially downloaded piece. The key is the piece index
and the value is a <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> where each bit represents a 16 kiB block.
A set bit means we have that block.</dd>
</dl>
<a name="have_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bhave_pieces%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bhave_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>have_pieces</dt>
<dd>this is a <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> indicating which pieces we already have of this
torrent.</dd>
</dl>
<a name="verified_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bverified_pieces%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bverified_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>verified_pieces</dt>
<dd>when in seed_mode, pieces with a set bit in this <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a> have been
verified to be valid. Other pieces will be verified the first time a
peer requests it.</dd>
</dl>
<a name="piece_priorities"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bpiece_priorities%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bpiece_priorities%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece_priorities</dt>
<dd>this sets the priorities for each individual piece in the torrent. Each
element in the vector represent the piece with the same index. If you
set both file- and piece priorities, file priorities will take
precedence.</dd>
</dl>
<a name="merkle_tree"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Bmerkle_tree%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Bmerkle_tree%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>merkle_tree</dt>
<dd>if this is a merkle tree torrent, and you're seeding, this field must
be set. It is all the hashes in the binary tree, with the root as the
first <a class="reference external" href="reference-Bencoding.html#entry">entry</a>. See <a class="reference external" href="reference-Core.html#set_merkle_tree()">torrent_info::set_merkle_tree()</a> for more info.</dd>
</dl>
<a name="renamed_files"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Brenamed_files%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Brenamed_files%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>renamed_files</dt>
<dd>this is a map of file indices in the torrent and new filenames to be
applied before the torrent is added.</dd>
</dl>
<a name="last_download"></a>
<a name="last_upload"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:add_torrent_params%3A%3A%5Blast_download+last_upload%5D&labels=documentation&body=Documentation+under+heading+%22add_torrent_params%3A%3A%5Blast_download+last_upload%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_download last_upload</dt>
<dd>the posix time of the last time payload was received or sent for this
torrent, respectively.</dd>
</dl>
<a name="peer_info"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_info&labels=documentation&body=Documentation+under+heading+%22class+peer_info%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-info">
<h2>peer_info</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_info.hpp">libtorrent/peer_info.hpp</a>&quot;</p>
<p>holds information and statistics about one peer
that libtorrent is connected to</p>
<pre class="literal-block">
struct peer_info
{
   enum connection_type_t
   {
      standard_bittorrent,
      web_seed,
      http_seed,
   };

   std::string client;
   typed_bitfield&lt;piece_index_t&gt; pieces;
   std::int64_t total_download;
   std::int64_t total_upload;
   time_duration last_request;
   time_duration last_active;
   time_duration download_queue_time;
   static constexpr peer_flags_t <strong>interesting</strong>  = 0_bit;
   static constexpr peer_flags_t <strong>choked</strong>  = 1_bit;
   static constexpr peer_flags_t <strong>remote_interested</strong>  = 2_bit;
   static constexpr peer_flags_t <strong>remote_choked</strong>  = 3_bit;
   static constexpr peer_flags_t <strong>supports_extensions</strong>  = 4_bit;
   static constexpr peer_flags_t <strong>local_connection</strong>  = 5_bit;
   static constexpr peer_flags_t <strong>handshake</strong>  = 6_bit;
   static constexpr peer_flags_t <strong>connecting</strong>  = 7_bit;
   static constexpr peer_flags_t <strong>on_parole</strong>  = 9_bit;
   static constexpr peer_flags_t <strong>seed</strong>  = 10_bit;
   static constexpr peer_flags_t <strong>optimistic_unchoke</strong>  = 11_bit;
   static constexpr peer_flags_t <strong>snubbed</strong>  = 12_bit;
   static constexpr peer_flags_t <strong>upload_only</strong>  = 13_bit;
   static constexpr peer_flags_t <strong>endgame_mode</strong>  = 14_bit;
   static constexpr peer_flags_t <strong>holepunched</strong>  = 15_bit;
   static constexpr peer_flags_t <strong>i2p_socket</strong>  = 16_bit;
   static constexpr peer_flags_t <strong>utp_socket</strong>  = 17_bit;
   static constexpr peer_flags_t <strong>ssl_socket</strong>  = 18_bit;
   static constexpr peer_flags_t <strong>rc4_encrypted</strong>  = 19_bit;
   static constexpr peer_flags_t <strong>plaintext_encrypted</strong>  = 20_bit;
   peer_flags_t flags;
   static constexpr peer_source_flags_t <strong>tracker</strong>  = 0_bit;
   static constexpr peer_source_flags_t <strong>dht</strong>  = 1_bit;
   static constexpr peer_source_flags_t <strong>pex</strong>  = 2_bit;
   static constexpr peer_source_flags_t <strong>lsd</strong>  = 3_bit;
   static constexpr peer_source_flags_t <strong>resume_data</strong>  = 4_bit;
   static constexpr peer_source_flags_t <strong>incoming</strong>  = 5_bit;
   peer_source_flags_t source;
   int up_speed;
   int down_speed;
   int payload_up_speed;
   int payload_down_speed;
   peer_id pid;
   int queue_bytes;
   int request_timeout;
   int send_buffer_size;
   int used_send_buffer;
   int receive_buffer_size;
   int used_receive_buffer;
   int receive_buffer_watermark;
   int num_hashfails;
   int download_queue_length;
   int timed_out_requests;
   int busy_requests;
   int requests_in_buffer;
   int target_dl_queue_length;
   int upload_queue_length;
   int failcount;
   piece_index_t downloading_piece_index;
   int downloading_block_index;
   int downloading_progress;
   int downloading_total;
   int connection_type;
   int pending_disk_bytes;
   int pending_disk_read_bytes;
   int send_quota;
   int receive_quota;
   int rtt;
   int num_pieces;
   int download_rate_peak;
   int upload_rate_peak;
   float progress;
   int progress_ppm;
   int deprecated_estimated_reciprocation_rate;
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> ip;
   <a class="reference external" href="tcp::endpoint">tcp::endpoint</a> local_endpoint;
   static constexpr bandwidth_state_flags_t <strong>bw_idle</strong>  = 0_bit;
   static constexpr bandwidth_state_flags_t <strong>bw_limit</strong>  = 1_bit;
   static constexpr bandwidth_state_flags_t <strong>bw_network</strong>  = 2_bit;
   static constexpr bandwidth_state_flags_t <strong>bw_disk</strong>  = 4_bit;
   bandwidth_state_flags_t read_state;
   bandwidth_state_flags_t write_state;
};
</pre>
<a name="connection_type_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+connection_type_t&labels=documentation&body=Documentation+under+heading+%22enum+connection_type_t%22+could+be+improved">report issue</a>]</span><div class="section" id="enum-connection-type-t">
<h3>enum connection_type_t</h3>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_info.hpp">libtorrent/peer_info.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="28%" />
<col width="9%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>standard_bittorrent</td>
<td>0</td>
<td>Regular bittorrent connection</td>
</tr>
<tr><td>web_seed</td>
<td>1</td>
<td>HTTP connection using the <a class="reference external" href="https://www.bittorrent.org/beps/bep_0019.html">BEP 19</a> protocol</td>
</tr>
<tr><td>http_seed</td>
<td>2</td>
<td>HTTP connection using the <a class="reference external" href="https://www.bittorrent.org/beps/bep_0017.html">BEP 17</a> protocol</td>
</tr>
</tbody>
</table>
<a name="client"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bclient%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bclient%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>client</dt>
<dd>a string describing the software at the other end of the connection.
In some cases this information is not available, then it will contain
a string that may give away something about which software is running
in the other end. In the case of a web seed, the server type and
version will be a part of this string.</dd>
</dl>
<a name="pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpieces%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pieces</dt>
<dd>a <a class="reference external" href="reference-Utility.html#bitfield">bitfield</a>, with one bit per piece in the torrent. Each bit tells you
if the peer has that piece (if it's set to 1) or if the peer miss that
piece (set to 0).</dd>
</dl>
<a name="total_download"></a>
<a name="total_upload"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Btotal_download+total_upload%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Btotal_download+total_upload%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>total_download total_upload</dt>
<dd>the total number of bytes downloaded from and uploaded to this peer.
These numbers do not include the protocol chatter, but only the
payload data.</dd>
</dl>
<a name="last_request"></a>
<a name="last_active"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Blast_request+last_active%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Blast_request+last_active%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>last_request last_active</dt>
<dd>the time since we last sent a request to this peer and since any
transfer occurred with this peer</dd>
</dl>
<a name="download_queue_time"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdownload_queue_time%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdownload_queue_time%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_queue_time</dt>
<dd>the time until all blocks in the request queue will be downloaded</dd>
</dl>
<a name="interesting"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Binteresting%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Binteresting%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>interesting</dt>
<dd><strong>we</strong> are interested in pieces from this peer.</dd>
</dl>
<a name="choked"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bchoked%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bchoked%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>choked</dt>
<dd><strong>we</strong> have choked this peer.</dd>
</dl>
<a name="remote_interested"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bremote_interested%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bremote_interested%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>remote_interested</dt>
<dd>the peer is interested in <strong>us</strong></dd>
</dl>
<a name="remote_choked"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bremote_choked%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bremote_choked%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>remote_choked</dt>
<dd>the peer has choked <strong>us</strong>.</dd>
</dl>
<a name="supports_extensions"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsupports_extensions%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsupports_extensions%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>supports_extensions</dt>
<dd>means that this peer supports the
<a class="reference external" href="extension_protocol.html">extension protocol</a>.</dd>
</dl>
<a name="local_connection"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Blocal_connection%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Blocal_connection%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_connection</dt>
<dd>The connection was initiated by us, the peer has a
listen port open, and that port is the same as in the
address of this peer. If this flag is not set, this
peer connection was opened by this peer connecting to
us.</dd>
</dl>
<a name="handshake"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bhandshake%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bhandshake%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>handshake</dt>
<dd>The connection is opened, and waiting for the
handshake. Until the handshake is done, the peer
cannot be identified.</dd>
</dl>
<a name="connecting"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bconnecting%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bconnecting%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connecting</dt>
<dd>The connection is in a half-open state (i.e. it is
being connected).</dd>
</dl>
<a name="on_parole"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bon_parole%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bon_parole%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>on_parole</dt>
<dd>The peer has participated in a piece that failed the
hash check, and is now &quot;on parole&quot;, which means we're
only requesting whole pieces from this peer until
it either fails that piece or proves that it doesn't
send bad data.</dd>
</dl>
<a name="seed"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bseed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bseed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>seed</dt>
<dd>This peer is a seed (it has all the pieces).</dd>
</dl>
<a name="optimistic_unchoke"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Boptimistic_unchoke%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Boptimistic_unchoke%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>optimistic_unchoke</dt>
<dd>This peer is subject to an optimistic unchoke. It has
been unchoked for a while to see if it might unchoke
us in return an earn an upload/unchoke slot. If it
doesn't within some period of time, it will be choked
and another peer will be optimistically unchoked.</dd>
</dl>
<a name="snubbed"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsnubbed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsnubbed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>snubbed</dt>
<dd>This peer has recently failed to send a block within
the request timeout from when the request was sent.
We're currently picking one block at a time from this
peer.</dd>
</dl>
<a name="upload_only"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bupload_only%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bupload_only%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_only</dt>
<dd>This peer has either explicitly (with an extension)
or implicitly (by becoming a seed) told us that it
will not downloading anything more, regardless of
which pieces we have.</dd>
</dl>
<a name="endgame_mode"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bendgame_mode%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bendgame_mode%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>endgame_mode</dt>
<dd>This means the last time this peer picket a piece,
it could not pick as many as it wanted because there
were not enough free ones. i.e. all pieces this peer
has were already requested from other peers.</dd>
</dl>
<a name="holepunched"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bholepunched%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bholepunched%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>holepunched</dt>
<dd>This flag is set if the peer was in holepunch mode
when the connection succeeded. This typically only
happens if both peers are behind a NAT and the peers
connect via the NAT holepunch mechanism.</dd>
</dl>
<a name="i2p_socket"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bi2p_socket%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bi2p_socket%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>i2p_socket</dt>
<dd>indicates that this socket is running on top of the
I2P transport.</dd>
</dl>
<a name="utp_socket"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Butp_socket%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Butp_socket%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>utp_socket</dt>
<dd>indicates that this socket is a uTP socket</dd>
</dl>
<a name="ssl_socket"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bssl_socket%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bssl_socket%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ssl_socket</dt>
<dd>indicates that this socket is running on top of an SSL
(TLS) channel</dd>
</dl>
<a name="rc4_encrypted"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Brc4_encrypted%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Brc4_encrypted%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>rc4_encrypted</dt>
<dd>this connection is obfuscated with RC4</dd>
</dl>
<a name="plaintext_encrypted"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bplaintext_encrypted%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bplaintext_encrypted%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>plaintext_encrypted</dt>
<dd>the handshake of this connection was obfuscated
with a Diffie-Hellman exchange</dd>
</dl>
<a name="flags"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bflags%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bflags%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>flags</dt>
<dd>tells you in which state the peer is in. It is set to
any combination of the peer_flags_t flags above.</dd>
</dl>
<a name="tracker"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Btracker%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Btracker%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>tracker</dt>
<dd>The peer was received from the tracker.</dd>
</dl>
<a name="dht"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdht%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdht%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>dht</dt>
<dd>The peer was received from the kademlia DHT.</dd>
</dl>
<a name="pex"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpex%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpex%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pex</dt>
<dd>The peer was received from the peer exchange
extension.</dd>
</dl>
<a name="lsd"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Blsd%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Blsd%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>lsd</dt>
<dd>The peer was received from the local service
discovery (The peer is on the local network).</dd>
</dl>
<a name="resume_data"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bresume_data%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bresume_data%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>resume_data</dt>
<dd>The peer was added from the fast resume data.</dd>
</dl>
<a name="incoming"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bincoming%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bincoming%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>incoming</dt>
<dd>we received an incoming connection from this peer</dd>
</dl>
<a name="source"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsource%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsource%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>source</dt>
<dd>a combination of flags describing from which sources this peer
was received. A combination of the peer_source_flags_t above.</dd>
</dl>
<a name="up_speed"></a>
<a name="down_speed"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bup_speed+down_speed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bup_speed+down_speed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>up_speed down_speed</dt>
<dd>the current upload and download speed we have to and from this peer
(including any protocol messages). updated about once per second</dd>
</dl>
<a name="payload_up_speed"></a>
<a name="payload_down_speed"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpayload_up_speed+payload_down_speed%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpayload_up_speed+payload_down_speed%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>payload_up_speed payload_down_speed</dt>
<dd>The transfer rates of payload data only updated about once per second</dd>
</dl>
<a name="pid"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpid%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpid%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pid</dt>
<dd>the peer's id as used in the bit torrent protocol. This id can be used
to extract 'fingerprints' from the peer. Sometimes it can tell you
which client the peer is using. See identify_client()_</dd>
</dl>
<a name="queue_bytes"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bqueue_bytes%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bqueue_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>queue_bytes</dt>
<dd>the number of bytes we have requested from this peer, but not yet
received.</dd>
</dl>
<a name="request_timeout"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Brequest_timeout%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Brequest_timeout%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>request_timeout</dt>
<dd>the number of seconds until the current front piece request will time
out. This timeout can be adjusted through
<tt class="docutils literal"><span class="pre">settings_pack::request_timeout</span></tt>.
-1 means that there is not outstanding request.</dd>
</dl>
<a name="send_buffer_size"></a>
<a name="used_send_buffer"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsend_buffer_size+used_send_buffer%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsend_buffer_size+used_send_buffer%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>send_buffer_size used_send_buffer</dt>
<dd>the number of bytes allocated
and used for the peer's send buffer, respectively.</dd>
</dl>
<a name="receive_buffer_size"></a>
<a name="used_receive_buffer"></a>
<a name="receive_buffer_watermark"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Breceive_buffer_size+used_receive_buffer+receive_buffer_watermark%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Breceive_buffer_size+used_receive_buffer+receive_buffer_watermark%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>receive_buffer_size used_receive_buffer receive_buffer_watermark</dt>
<dd>the number of bytes
allocated and used as receive buffer, respectively.</dd>
</dl>
<a name="num_hashfails"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bnum_hashfails%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bnum_hashfails%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_hashfails</dt>
<dd>the number of pieces this peer has participated in sending us that
turned out to fail the hash check.</dd>
</dl>
<a name="download_queue_length"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdownload_queue_length%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdownload_queue_length%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_queue_length</dt>
<dd>this is the number of requests we have sent to this peer that we
haven't got a response for yet</dd>
</dl>
<a name="timed_out_requests"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Btimed_out_requests%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Btimed_out_requests%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>timed_out_requests</dt>
<dd>the number of block requests that have timed out, and are still in the
download queue</dd>
</dl>
<a name="busy_requests"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbusy_requests%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbusy_requests%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>busy_requests</dt>
<dd>the number of busy requests in the download queue. A busy request is a
request for a block we've also requested from a different peer</dd>
</dl>
<a name="requests_in_buffer"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Brequests_in_buffer%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Brequests_in_buffer%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>requests_in_buffer</dt>
<dd>the number of requests messages that are currently in the send buffer
waiting to be sent.</dd>
</dl>
<a name="target_dl_queue_length"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Btarget_dl_queue_length%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Btarget_dl_queue_length%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>target_dl_queue_length</dt>
<dd>the number of requests that is tried to be maintained (this is
typically a function of download speed)</dd>
</dl>
<a name="upload_queue_length"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bupload_queue_length%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bupload_queue_length%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>upload_queue_length</dt>
<dd>the number of piece-requests we have received from this peer
that we haven't answered with a piece yet.</dd>
</dl>
<a name="failcount"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bfailcount%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bfailcount%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>failcount</dt>
<dd>the number of times this peer has &quot;failed&quot;. i.e. failed to connect or
disconnected us. The failcount is decremented when we see this peer in
a tracker response or peer exchange message.</dd>
</dl>
<a name="downloading_piece_index"></a>
<a name="downloading_block_index"></a>
<a name="downloading_progress"></a>
<a name="downloading_total"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdownloading_piece_index+downloading_block_index+downloading_progress+downloading_total%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdownloading_piece_index+downloading_block_index+downloading_progress+downloading_total%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>downloading_piece_index downloading_block_index downloading_progress downloading_total</dt>
<dd>You can know which piece, and which part of that piece, that is
currently being downloaded from a specific peer by looking at these
four members. <tt class="docutils literal">downloading_piece_index</tt> is the index of the piece
that is currently being downloaded. This may be set to -1 if there's
currently no piece downloading from this peer. If it is &gt;= 0, the
other three members are valid. <tt class="docutils literal">downloading_block_index</tt> is the
index of the block (or sub-piece) that is being downloaded.
<tt class="docutils literal">downloading_progress</tt> is the number of bytes of this block we have
received from the peer, and <tt class="docutils literal">downloading_total</tt> is the total number
of bytes in this block.</dd>
</dl>
<a name="connection_type"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bconnection_type%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bconnection_type%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>connection_type</dt>
<dd>the kind of connection this peer uses. See <a class="reference external" href="reference-Core.html#connection_type_t">connection_type_t</a>.</dd>
</dl>
<a name="pending_disk_bytes"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpending_disk_bytes%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpending_disk_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pending_disk_bytes</dt>
<dd>the number of bytes this peer has pending in the disk-io thread.
Downloaded and waiting to be written to disk. This is what is capped
by <tt class="docutils literal"><span class="pre">settings_pack::max_queued_disk_bytes</span></tt>.</dd>
</dl>
<a name="pending_disk_read_bytes"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bpending_disk_read_bytes%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bpending_disk_read_bytes%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>pending_disk_read_bytes</dt>
<dd>number of outstanding bytes to read
from disk</dd>
</dl>
<a name="send_quota"></a>
<a name="receive_quota"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bsend_quota+receive_quota%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bsend_quota+receive_quota%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>send_quota receive_quota</dt>
<dd>the number of bytes this peer has been assigned to be allowed to send
and receive until it has to request more quota from the bandwidth
manager.</dd>
</dl>
<a name="rtt"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Brtt%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Brtt%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>rtt</dt>
<dd>an estimated round trip time to this peer, in milliseconds. It is
estimated by timing the TCP <tt class="docutils literal">connect()</tt>. It may be 0 for
incoming connections.</dd>
</dl>
<a name="num_pieces"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bnum_pieces%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bnum_pieces%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>num_pieces</dt>
<dd>the number of pieces this peer has.</dd>
</dl>
<a name="download_rate_peak"></a>
<a name="upload_rate_peak"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bdownload_rate_peak+upload_rate_peak%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bdownload_rate_peak+upload_rate_peak%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>download_rate_peak upload_rate_peak</dt>
<dd>the highest download and upload rates seen on this connection. They
are given in bytes per second. This number is reset to 0 on reconnect.</dd>
</dl>
<a name="progress"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bprogress%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bprogress%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>progress</dt>
<dd>the progress of the peer in the range [0, 1]. This is always 0 when
floating point operations are disabled, instead use <tt class="docutils literal">progress_ppm</tt>.</dd>
</dl>
<a name="progress_ppm"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bprogress_ppm%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bprogress_ppm%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>progress_ppm</dt>
<dd>indicates the download progress of the peer in the range [0, 1000000]
(parts per million).</dd>
</dl>
<a name="ip"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bip%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bip%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>ip</dt>
<dd>the IP-address to this peer. The type is an asio endpoint. For
more info, see the <a class="reference external" href="http://asio.sourceforge.net/asio-0.3.8/doc/asio/reference.html">asio</a> documentation.</dd>
</dl>
<a name="local_endpoint"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Blocal_endpoint%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Blocal_endpoint%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>local_endpoint</dt>
<dd>the IP and port pair the socket is bound to locally. i.e. the IP
address of the interface it's going out over. This may be useful for
multi-homed clients with multiple interfaces to the internet.</dd>
</dl>
<a name="bw_idle"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbw_idle%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbw_idle%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bw_idle</dt>
<dd>The peer is not waiting for any external events to
send or receive data.</dd>
</dl>
<a name="bw_limit"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbw_limit%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbw_limit%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bw_limit</dt>
<dd>The peer is waiting for the rate limiter.</dd>
</dl>
<a name="bw_network"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbw_network%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbw_network%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bw_network</dt>
<dd>The peer has quota and is currently waiting for a
network read or write operation to complete. This is
the state all peers are in if there are no bandwidth
limits.</dd>
</dl>
<a name="bw_disk"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bbw_disk%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bbw_disk%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>bw_disk</dt>
<dd>The peer is waiting for the disk I/O thread to catch
up writing buffers to disk before downloading more.</dd>
</dl>
<a name="read_state"></a>
<a name="write_state"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_info%3A%3A%5Bread_state+write_state%5D&labels=documentation&body=Documentation+under+heading+%22peer_info%3A%3A%5Bread_state+write_state%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>read_state write_state</dt>
<dd>bitmasks indicating what state this peer
is in with regards to sending and receiving data. The states are
defined as independent flags of type bandwidth_state_flags_t, in this
class.</dd>
</dl>
<a name="peer_request"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:class+peer_request&labels=documentation&body=Documentation+under+heading+%22class+peer_request%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="peer-request">
<h2>peer_request</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_request.hpp">libtorrent/peer_request.hpp</a>&quot;</p>
<p>represents a byte range within a piece. Internally this is
is used for incoming piece requests.</p>
<pre class="literal-block">
struct peer_request
{
   bool <strong>operator==</strong> (peer_request const&amp; r) const;

   piece_index_t piece;
   int start;
   int length;
};
</pre>
<a name="operator==()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_request%3A%3A%5Boperator%3D%3D%28%29%5D&labels=documentation&body=Documentation+under+heading+%22peer_request%3A%3A%5Boperator%3D%3D%28%29%5D%22+could+be+improved">report issue</a>]</span><div class="section" id="id209">
<h3>operator==()</h3>
<pre class="literal-block">
bool <strong>operator==</strong> (peer_request const&amp; r) const;
</pre>
<p>returns true if the right hand side <a class="reference external" href="reference-Core.html#peer_request">peer_request</a> refers to the same
range as this does.</p>
<a name="piece"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_request%3A%3A%5Bpiece%5D&labels=documentation&body=Documentation+under+heading+%22peer_request%3A%3A%5Bpiece%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>piece</dt>
<dd>the index of the piece in which the range starts.</dd>
</dl>
<a name="start"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_request%3A%3A%5Bstart%5D&labels=documentation&body=Documentation+under+heading+%22peer_request%3A%3A%5Bstart%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>start</dt>
<dd>the offset within that piece where the range starts.</dd>
</dl>
<a name="length"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:peer_request%3A%3A%5Blength%5D&labels=documentation&body=Documentation+under+heading+%22peer_request%3A%3A%5Blength%5D%22+could+be+improved">report issue</a>]</span><dl class="docutils">
<dt>length</dt>
<dd>the size of the range, in bytes.</dd>
</dl>
<a name="write_resume_data()"></a>
<a name="write_resume_data_buf()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:write_resume_data%28%29+write_resume_data_buf%28%29&labels=documentation&body=Documentation+under+heading+%22write_resume_data%28%29+write_resume_data_buf%28%29%22+could+be+improved">report issue</a>]</span></div>
</div>
<div class="section" id="write-resume-data-write-resume-data-buf">
<h2>write_resume_data() write_resume_data_buf()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/write_resume_data.hpp">libtorrent/write_resume_data.hpp</a>&quot;</p>
<pre class="literal-block">
entry <strong>write_resume_data</strong> (add_torrent_params const&amp; atp);
std::vector&lt;char&gt; <strong>write_resume_data_buf</strong> (add_torrent_params const&amp; atp);
</pre>
<p>this function turns the resume data in an <tt class="docutils literal">add_torrent_params</tt> object
into a bencoded structure</p>
<a name="make_magnet_uri()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:make_magnet_uri%28%29&labels=documentation&body=Documentation+under+heading+%22make_magnet_uri%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="make-magnet-uri">
<h2>make_magnet_uri()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/magnet_uri.hpp">libtorrent/magnet_uri.hpp</a>&quot;</p>
<pre class="literal-block">
std::string <strong>make_magnet_uri</strong> (torrent_handle const&amp; handle);
std::string <strong>make_magnet_uri</strong> (torrent_info const&amp; info);
</pre>
<p>Generates a magnet URI from the specified torrent. If the torrent
handle is invalid, an empty string is returned.</p>
<p>For more information about magnet links, see <a class="reference external" href="manual-ref.html#magnet-links">magnet links</a>.</p>
<a name="parse_magnet_uri()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:parse_magnet_uri%28%29&labels=documentation&body=Documentation+under+heading+%22parse_magnet_uri%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="parse-magnet-uri">
<h2>parse_magnet_uri()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/magnet_uri.hpp">libtorrent/magnet_uri.hpp</a>&quot;</p>
<pre class="literal-block">
void <strong>parse_magnet_uri</strong> (string_view uri, add_torrent_params&amp; p, error_code&amp; ec);
add_torrent_params <strong>parse_magnet_uri</strong> (string_view uri);
add_torrent_params <strong>parse_magnet_uri</strong> (string_view uri, error_code&amp; ec);
</pre>
<p>This function parses out information from the magnet link and populates the
<a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> object. The overload that does not take an
<tt class="docutils literal">error_code</tt> reference will throw a system_error on error
The overload taking an <tt class="docutils literal">add_torrent_params</tt> reference will fill in the
fields specified in the magnet URI.</p>
<a name="version()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:version%28%29&labels=documentation&body=Documentation+under+heading+%22version%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="version">
<h2>version()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/version.hpp">libtorrent/version.hpp</a>&quot;</p>
<pre class="literal-block">
char const* <strong>version</strong> ();
</pre>
<p>returns the libtorrent version as string form in this format:
&quot;&lt;major&gt;.&lt;minor&gt;.&lt;tiny&gt;.&lt;tag&gt;&quot;</p>
<a name="generate_fingerprint()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:generate_fingerprint%28%29&labels=documentation&body=Documentation+under+heading+%22generate_fingerprint%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="generate-fingerprint">
<h2>generate_fingerprint()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/fingerprint.hpp">libtorrent/fingerprint.hpp</a>&quot;</p>
<pre class="literal-block">
std::string <strong>generate_fingerprint</strong> (std::string name
   , int major, int minor = 0, int revision = 0, int tag = 0);
</pre>
<p>This is a utility function to produce a client ID fingerprint formatted to
the most common convention. The fingerprint can be set via the
<tt class="docutils literal">peer_fingerprint</tt> setting, in <a class="reference external" href="reference-Settings.html#settings_pack">settings_pack</a>.</p>
<p>The name string should contain exactly two characters. These are the
characters unique to your client, used to identify it. Make sure not to
clash with anybody else. Here are some taken id's:</p>
<table border="1" class="docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">id chars</th>
<th class="head">client</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>LT</td>
<td>libtorrent (default)</td>
</tr>
<tr><td>UT</td>
<td>uTorrent</td>
</tr>
<tr><td>UM</td>
<td>uTorrent Mac</td>
</tr>
<tr><td>qB</td>
<td>qBittorrent</td>
</tr>
<tr><td>BP</td>
<td>BitTorrent Pro</td>
</tr>
<tr><td>BT</td>
<td>BitTorrent</td>
</tr>
<tr><td>DE</td>
<td>Deluge</td>
</tr>
<tr><td>AZ</td>
<td>Azureus</td>
</tr>
<tr><td>TL</td>
<td>Tribler</td>
</tr>
</tbody>
</table>
<p>There's an informal directory of client id's <a class="reference external" href="http://wiki.theory.org/BitTorrentSpecification#peer_id">here</a>.</p>
<p>The <tt class="docutils literal">major</tt>, <tt class="docutils literal">minor</tt>, <tt class="docutils literal">revision</tt> and <tt class="docutils literal">tag</tt> parameters are used to
identify the version of your client.</p>
<a name="hash_value()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:hash_value%28%29&labels=documentation&body=Documentation+under+heading+%22hash_value%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="hash-value">
<h2>hash_value()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_handle.hpp">libtorrent/torrent_handle.hpp</a>&quot;</p>
<pre class="literal-block">
std::size_t <strong>hash_value</strong> (torrent_handle const&amp; h);
</pre>
<p>for std::hash (and to support using this type in unordered_map etc.)</p>
<a name="is_utp_stream_logging()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:is_utp_stream_logging%28%29&labels=documentation&body=Documentation+under+heading+%22is_utp_stream_logging%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="is-utp-stream-logging">
<h2>is_utp_stream_logging()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/utp_stream.hpp">libtorrent/utp_stream.hpp</a>&quot;</p>
<pre class="literal-block">
bool <strong>is_utp_stream_logging</strong> ();
</pre>
<a name="set_utp_stream_logging()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:set_utp_stream_logging%28%29&labels=documentation&body=Documentation+under+heading+%22set_utp_stream_logging%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="set-utp-stream-logging">
<h2>set_utp_stream_logging()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/utp_stream.hpp">libtorrent/utp_stream.hpp</a>&quot;</p>
<pre class="literal-block">
void <strong>set_utp_stream_logging</strong> (bool enable);
</pre>
<p>This function should be used at the very beginning and very end of your program.</p>
<a name="read_resume_data()"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:read_resume_data%28%29&labels=documentation&body=Documentation+under+heading+%22read_resume_data%28%29%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="read-resume-data">
<h2>read_resume_data()</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/read_resume_data.hpp">libtorrent/read_resume_data.hpp</a>&quot;</p>
<pre class="literal-block">
add_torrent_params <strong>read_resume_data</strong> (span&lt;char const&gt; buffer
   , error_code&amp; ec);
add_torrent_params <strong>read_resume_data</strong> (bdecode_node const&amp; rd
   , error_code&amp; ec);
add_torrent_params <strong>read_resume_data</strong> (span&lt;char const&gt; buffer);
add_torrent_params <strong>read_resume_data</strong> (bdecode_node const&amp; rd);
</pre>
<p>these functions are used to parse resume data and populate the appropriate
fields in an <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> object. This object can then be used to add
the actual <a class="reference external" href="reference-Core.html#torrent_info">torrent_info</a> object to and pass to session::add_torrent() or
session::async_add_torrent().</p>
<p>If the client wants to override any field that was loaded from the resume
data, e.g. save_path, those fields must be changed after loading resume
data but before adding the torrent.</p>
<a name="connection_type"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+connection_type&labels=documentation&body=Documentation+under+heading+%22enum+connection_type%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-connection-type">
<h2>enum connection_type</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/peer_connection.hpp">libtorrent/peer_connection.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="22%" />
<col width="41%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>bittorrent</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>url_seed</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>http_seed</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="portmap_transport"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+portmap_transport&labels=documentation&body=Documentation+under+heading+%22enum+portmap_transport%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-portmap-transport">
<h2>enum portmap_transport</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/portmap.hpp">libtorrent/portmap.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="16%" />
<col width="67%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>natpmp</td>
<td>0</td>
<td>natpmp can be NAT-PMP or PCP</td>
</tr>
<tr><td>upnp</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="portmap_protocol"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:enum+portmap_protocol&labels=documentation&body=Documentation+under+heading+%22enum+portmap_protocol%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="enum-portmap-protocol">
<h2>enum portmap_protocol</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/portmap.hpp">libtorrent/portmap.hpp</a>&quot;</p>
<table border="1" class="docutils">
<colgroup>
<col width="23%" />
<col width="27%" />
<col width="50%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">name</th>
<th class="head">value</th>
<th class="head">description</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>none</td>
<td>0</td>
<td>&nbsp;</td>
</tr>
<tr><td>tcp</td>
<td>1</td>
<td>&nbsp;</td>
</tr>
<tr><td>udp</td>
<td>2</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
<a name="torrent_flags_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:torrent_flags_t&labels=documentation&body=Documentation+under+heading+%22torrent_flags_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="torrent-flags-t">
<h2>torrent_flags_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/torrent_flags.hpp">libtorrent/torrent_flags.hpp</a>&quot;</p>
<a name="torrent_flags_t::seed_mode"></a><dl class="docutils">
<dt>seed_mode</dt>
<dd><p class="first">If <tt class="docutils literal">seed_mode</tt> is set, libtorrent will assume that all files
are present for this torrent and that they all match the hashes in
the torrent file. Each time a peer requests to download a block,
the piece is verified against the hash, unless it has been verified
already. If a hash fails, the torrent will automatically leave the
seed mode and recheck all the files. The use case for this mode is
if a torrent is created and seeded, or if the user already know
that the files are complete, this is a way to avoid the initial
file checks, and significantly reduce the startup time.</p>
<p>Setting <tt class="docutils literal">seed_mode</tt> on a torrent without metadata (a
.torrent file) is a no-op and will be ignored.</p>
<p class="last">It is not possible to <em>set</em> the <tt class="docutils literal">seed_mode</tt> flag on a torrent after it has
been added to a <a class="reference external" href="reference-Session.html#session">session</a>. It is possible to <em>clear</em> it though.</p>
</dd>
</dl>
<a name="torrent_flags_t::upload_mode"></a><dl class="docutils">
<dt>upload_mode</dt>
<dd><p class="first">If <tt class="docutils literal">upload_mode</tt> is set, the torrent will be initialized in
upload-mode, which means it will not make any piece requests. This
state is typically entered on disk I/O errors, and if the torrent
is also auto managed, it will be taken out of this state
periodically (see <tt class="docutils literal"><span class="pre">settings_pack::optimistic_disk_retry</span></tt>).</p>
<p>This mode can be used to avoid race conditions when
adjusting priorities of pieces before allowing the torrent to start
downloading.</p>
<p class="last">If the torrent is auto-managed (<tt class="docutils literal">auto_managed</tt>), the torrent
will eventually be taken out of upload-mode, regardless of how it
got there. If it's important to manually control when the torrent
leaves upload mode, don't make it auto managed.</p>
</dd>
</dl>
<a name="torrent_flags_t::share_mode"></a><dl class="docutils">
<dt>share_mode</dt>
<dd><p class="first">determines if the torrent should be added in <em>share mode</em> or not.
Share mode indicates that we are not interested in downloading the
torrent, but merely want to improve our share ratio (i.e. increase
it). A torrent started in share mode will do its best to never
download more than it uploads to the swarm. If the swarm does not
have enough demand for upload capacity, the torrent will not
download anything. This mode is intended to be safe to add any
number of torrents to, without manual screening, without the risk
of downloading more than is uploaded.</p>
<p>A torrent in share mode sets the priority to all pieces to 0,
except for the pieces that are downloaded, when pieces are decided
to be downloaded. This affects the progress bar, which might be set
to &quot;100% finished&quot; most of the time. Do not change file or piece
priorities for torrents in share mode, it will make it not work.</p>
<p class="last">The share mode has one setting, the share ratio target, see
<tt class="docutils literal"><span class="pre">settings_pack::share_mode_target</span></tt> for more info.</p>
</dd>
</dl>
<a name="torrent_flags_t::apply_ip_filter"></a><dl class="docutils">
<dt>apply_ip_filter</dt>
<dd>determines if the IP filter should apply to this torrent or not. By
default all torrents are subject to filtering by the IP filter
(i.e. this flag is set by default). This is useful if certain
torrents needs to be exempt for some reason, being an auto-update
torrent for instance.</dd>
</dl>
<a name="torrent_flags_t::paused"></a><dl class="docutils">
<dt>paused</dt>
<dd>specifies whether or not the torrent is paused. i.e. it won't connect to the tracker or any of the peers
until it's resumed. Note that a paused torrent that also has the
auto_managed flag set can be started at any time by libtorrent's queuing
logic. See <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</dd>
</dl>
<a name="torrent_flags_t::auto_managed"></a><dl class="docutils">
<dt>auto_managed</dt>
<dd><p class="first">If the torrent is auto-managed (<tt class="docutils literal">auto_managed</tt>), the torrent
may be resumed at any point, regardless of how it paused. If it's
important to manually control when the torrent is paused and
resumed, don't make it auto managed.</p>
<p class="last">If <tt class="docutils literal">auto_managed</tt> is set, the torrent will be queued,
started and seeded automatically by libtorrent. When this is set,
the torrent should also be started as paused. The default queue
order is the order the torrents were added. They are all downloaded
in that order. For more details, see <a class="reference external" href="manual-ref.html#queuing">queuing</a>.</p>
</dd>
</dl>
<a name="torrent_flags_t::duplicate_is_error"></a><dl class="docutils">
<dt>duplicate_is_error</dt>
<dd>used in <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> to indicate that it's an error to attempt
to add a torrent that's already in the <a class="reference external" href="reference-Session.html#session">session</a>. If it's not considered an
error, a handle to the existing torrent is returned.
This flag is not saved by <a class="reference external" href="reference-Core.html#write_resume_data()">write_resume_data()</a>, since it is only meant for
adding torrents.</dd>
</dl>
<a name="torrent_flags_t::update_subscribe"></a><dl class="docutils">
<dt>update_subscribe</dt>
<dd>on by default and means that this torrent will be part of state
updates when calling <a class="reference external" href="reference-Session.html#post_torrent_updates()">post_torrent_updates()</a>.
This flag is not saved by <a class="reference external" href="reference-Core.html#write_resume_data()">write_resume_data()</a>.</dd>
</dl>
<a name="torrent_flags_t::super_seeding"></a><dl class="docutils">
<dt>super_seeding</dt>
<dd>sets the torrent into super seeding/initial seeding mode. If the torrent
is not a seed, this flag has no effect.</dd>
</dl>
<a name="torrent_flags_t::sequential_download"></a><dl class="docutils">
<dt>sequential_download</dt>
<dd>sets the sequential download state for the torrent. In this mode the
piece picker will pick pieces with low index numbers before pieces with
high indices. The actual pieces that are picked depend on other factors
still, such as which pieces a peer has and whether it is in parole mode
or &quot;prefer whole pieces&quot;-mode. Sequential mode is not ideal for streaming
media. For that, see <a class="reference external" href="reference-Core.html#set_piece_deadline()">set_piece_deadline()</a> instead.</dd>
</dl>
<a name="torrent_flags_t::stop_when_ready"></a><dl class="docutils">
<dt>stop_when_ready</dt>
<dd><p class="first">When this flag is set, the torrent will <em>force stop</em> whenever it
transitions from a non-data-transferring state into a data-transferring
state (referred to as being ready to download or seed). This is useful
for torrents that should not start downloading or seeding yet, but want
to be made ready to do so. A torrent may need to have its files checked
for instance, so it needs to be started and possibly queued for checking
(auto-managed and started) but as soon as it's done, it should be
stopped.</p>
<p><em>Force stopped</em> means auto-managed is set to false and it's paused. As
if the auto_manages flag is cleared and the paused flag is set on the torrent.</p>
<p>Note that the torrent may transition into a downloading state while
setting this flag, and since the logic is edge triggered you may
miss the edge. To avoid this race, if the torrent already is in a
downloading state when this call is made, it will trigger the
stop-when-ready immediately.</p>
<p>When the stop-when-ready logic fires, the flag is cleared. Any
subsequent transitions between downloading and non-downloading states
will not be affected, until this flag is set again.</p>
<p>The behavior is more robust when setting this flag as part of adding
the torrent. See <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a>.</p>
<p>The stop-when-ready flag fixes the inherent race condition of waiting
for the <a class="reference external" href="reference-Alerts.html#state_changed_alert">state_changed_alert</a> and then call <a class="reference external" href="reference-Core.html#pause()">pause()</a>. The download/seeding
will most likely start in between posting the <a class="reference external" href="reference-Alerts.html#alert">alert</a> and receiving the
call to pause.</p>
<p class="last">A downloading state is one where peers are being connected. Which means
just downloading the metadata via the <tt class="docutils literal">ut_metadata</tt> extension counts
as a downloading state. In order to stop a torrent once the metadata
has been downloaded, instead set all file priorities to dont_download</p>
</dd>
</dl>
<a name="torrent_flags_t::override_trackers"></a><dl class="docutils">
<dt>override_trackers</dt>
<dd>when this flag is set, the tracker list in the <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a>
object override any trackers from the torrent file. If the flag is
not set, the trackers from the <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> object will be
added to the list of trackers used by the torrent.
This flag is set by <a class="reference external" href="reference-Core.html#read_resume_data()">read_resume_data()</a> if there are trackers present in
the resume data file. This effectively makes the trackers saved in the
resume data take precedence over the original trackers. This includes if
there's an empty list of trackers, to support the case where they were
explicitly removed in the previous <a class="reference external" href="reference-Session.html#session">session</a>.
This flag is not saved by <a class="reference external" href="reference-Core.html#write_resume_data()">write_resume_data()</a></dd>
</dl>
<a name="torrent_flags_t::override_web_seeds"></a><dl class="docutils">
<dt>override_web_seeds</dt>
<dd>If this flag is set, the web seeds from the <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a>
object will override any web seeds in the torrent file. If it's not
set, web seeds in the <a class="reference external" href="reference-Core.html#add_torrent_params">add_torrent_params</a> object will be added to the
list of web seeds used by the torrent.
This flag is set by <a class="reference external" href="reference-Core.html#read_resume_data()">read_resume_data()</a> if there are web seeds present in
the resume data file. This effectively makes the web seeds saved in the
resume data take precedence over the original ones. This includes if
there's an empty list of web seeds, to support the case where they were
explicitly removed in the previous <a class="reference external" href="reference-Session.html#session">session</a>.
This flag is not saved by <a class="reference external" href="reference-Core.html#write_resume_data()">write_resume_data()</a></dd>
</dl>
<a name="torrent_flags_t::need_save_resume"></a><dl class="docutils">
<dt>need_save_resume</dt>
<dd>if this flag is set (which it is by default) the torrent will be
considered needing to save its resume data immediately as it's
added. New torrents that don't have any resume data should do that.
This flag is cleared by a successful call to <a class="reference external" href="reference-Core.html#save_resume_data()">save_resume_data()</a>
This flag is not saved by <a class="reference external" href="reference-Core.html#write_resume_data()">write_resume_data()</a>, since it represents an
ephemeral state of a running torrent.</dd>
</dl>
<a name="torrent_flags_t::disable_dht"></a><dl class="docutils">
<dt>disable_dht</dt>
<dd>set this flag to disable DHT for this torrent. This lets you have the DHT
enabled for the whole client, and still have specific torrents not
participating in it. i.e. not announcing to the DHT nor picking up peers
from it.</dd>
</dl>
<a name="torrent_flags_t::disable_lsd"></a><dl class="docutils">
<dt>disable_lsd</dt>
<dd>set this flag to disable local service discovery for this torrent.</dd>
</dl>
<a name="torrent_flags_t::disable_pex"></a><dl class="docutils">
<dt>disable_pex</dt>
<dd>set this flag to disable peer exchange for this torrent.</dd>
</dl>
<a name="torrent_flags_t::all"></a><dl class="docutils">
<dt>all</dt>
<dd>all torrent flags combined. Can conveniently be used when creating masks
for flags</dd>
</dl>
<a name="download_priority_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:download_priority_t&labels=documentation&body=Documentation+under+heading+%22download_priority_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="download-priority-t">
<h2>download_priority_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/download_priority.hpp">libtorrent/download_priority.hpp</a>&quot;</p>
<a name="download_priority_t::dont_download"></a><dl class="docutils">
<dt>dont_download</dt>
<dd>Don't download the file or piece. Partial pieces may still be downloaded when
setting file priorities.</dd>
</dl>
<a name="download_priority_t::default_priority"></a><dl class="docutils">
<dt>default_priority</dt>
<dd>The default priority for files and pieces.</dd>
</dl>
<a name="download_priority_t::low_priority"></a><dl class="docutils">
<dt>low_priority</dt>
<dd>The lowest priority for files and pieces.</dd>
</dl>
<a name="download_priority_t::top_priority"></a><dl class="docutils">
<dt>top_priority</dt>
<dd>The highest priority for files and pieces.</dd>
</dl>
<a name="pex_flags_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:pex_flags_t&labels=documentation&body=Documentation+under+heading+%22pex_flags_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="pex-flags-t">
<h2>pex_flags_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/pex_flags.hpp">libtorrent/pex_flags.hpp</a>&quot;</p>
<a name="pex_flags_t::pex_encryption"></a><dl class="docutils">
<dt>pex_encryption</dt>
<dd>the peer supports protocol encryption</dd>
</dl>
<a name="pex_flags_t::pex_seed"></a><dl class="docutils">
<dt>pex_seed</dt>
<dd>the peer is a seed</dd>
</dl>
<a name="pex_flags_t::pex_utp"></a><dl class="docutils">
<dt>pex_utp</dt>
<dd>the peer supports the uTP, transport protocol over UDP.</dd>
</dl>
<a name="pex_flags_t::pex_holepunch"></a><dl class="docutils">
<dt>pex_holepunch</dt>
<dd>the peer supports the holepunch extension If this flag is received from a
peer, it can be used as a rendezvous point in case direct connections to
the peer fail</dd>
</dl>
<a name="file_open_mode_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:file_open_mode_t&labels=documentation&body=Documentation+under+heading+%22file_open_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="file-open-mode-t">
<h2>file_open_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/disk_interface.hpp">libtorrent/disk_interface.hpp</a>&quot;</p>
<a name="file_open_mode_t::read_only"></a><dl class="docutils">
<dt>read_only</dt>
<dd>open the file for reading only</dd>
</dl>
<a name="file_open_mode_t::write_only"></a><dl class="docutils">
<dt>write_only</dt>
<dd>open the file for writing only</dd>
</dl>
<a name="file_open_mode_t::read_write"></a><dl class="docutils">
<dt>read_write</dt>
<dd>open the file for reading and writing</dd>
</dl>
<a name="file_open_mode_t::rw_mask"></a><dl class="docutils">
<dt>rw_mask</dt>
<dd>the mask for the bits determining read or write mode</dd>
</dl>
<a name="file_open_mode_t::sparse"></a><dl class="docutils">
<dt>sparse</dt>
<dd>open the file in sparse mode (if supported by the
filesystem).</dd>
</dl>
<a name="file_open_mode_t::no_atime"></a><dl class="docutils">
<dt>no_atime</dt>
<dd>don't update the access timestamps on the file (if
supported by the operating system and filesystem).
this generally improves disk performance.</dd>
</dl>
<a name="file_open_mode_t::random_access"></a><dl class="docutils">
<dt>random_access</dt>
<dd>open the file for random access. This disables read-ahead
logic</dd>
</dl>
<a name="open_mode_t"></a><span style="float:right;">[<a style="color:blue;" href="http://github.com/arvidn/libtorrent/issues/new?title=docs:open_mode_t&labels=documentation&body=Documentation+under+heading+%22open_mode_t%22+could+be+improved">report issue</a>]</span></div>
<div class="section" id="open-mode-t">
<h2>open_mode_t</h2>
<p>Declared in &quot;<a class="reference external" href="../include/libtorrent/file.hpp">libtorrent/file.hpp</a>&quot;</p>
<a name="open_mode_t::read_only"></a><dl class="docutils">
<dt>read_only</dt>
<dd>open the file for reading only</dd>
</dl>
<a name="open_mode_t::write_only"></a><dl class="docutils">
<dt>write_only</dt>
<dd>open the file for writing only</dd>
</dl>
<a name="open_mode_t::read_write"></a><dl class="docutils">
<dt>read_write</dt>
<dd>open the file for reading and writing</dd>
</dl>
<a name="open_mode_t::rw_mask"></a><dl class="docutils">
<dt>rw_mask</dt>
<dd>the mask for the bits making up the read-write mode.</dd>
</dl>
<a name="open_mode_t::sparse"></a><dl class="docutils">
<dt>sparse</dt>
<dd>open the file in sparse mode (if supported by the
filesystem).</dd>
</dl>
<a name="open_mode_t::no_atime"></a><dl class="docutils">
<dt>no_atime</dt>
<dd>don't update the access timestamps on the file (if
supported by the operating system and filesystem).
this generally improves disk performance.</dd>
</dl>
<a name="open_mode_t::random_access"></a><dl class="docutils">
<dt>random_access</dt>
<dd>open the file for random access. This disables read-ahead
logic</dd>
</dl>
<a name="open_mode_t::no_cache"></a><dl class="docutils">
<dt>no_cache</dt>
<dd>don't put any pressure on the OS disk cache
because of access to this file. We expect our
files to be fairly large, and there is already
a cache at the bittorrent block level. This
may improve overall system performance by
leaving running applications in the page cache</dd>
</dl>
<a name="open_mode_t::coalesce_buffers"></a><dl class="docutils">
<dt>coalesce_buffers</dt>
<dd>this is only used for readv/writev flags</dd>
</dl>
<a name="open_mode_t::attribute_hidden"></a><dl class="docutils">
<dt>attribute_hidden</dt>
<dd>when creating a file, set the hidden attribute (windows only)</dd>
</dl>
<a name="open_mode_t::attribute_executable"></a><dl class="docutils">
<dt>attribute_executable</dt>
<dd>when creating a file, set the executable attribute</dd>
</dl>
<a name="open_mode_t::attribute_mask"></a><dl class="docutils">
<dt>attribute_mask</dt>
<dd>the mask of all attribute bits</dd>
</dl>
</div>
</div>

    </div>
    </div>
    <div id="gradient"></div>
    <div id="footer">
    <table>
    <tr>
      <td><a href="index.html">home</a></td>
      <td><a href="https://blog.libtorrent.org">blog</a></td>
      <td><a href="utp.html">uTP</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/libtorrent/">download</a></td>
      <td><a href="reference.html">documentation</a></td>
      <td><a href="dht_store.html">DHT put extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/projects/libtorrent/files/py-libtorrent/">python bindings</a></td>
      <td><a href="features.html">features</a></td>
      <td><a href="dht_sec.html">DHT security extension</a></td>
    </tr>
    <tr>
      <td><a href="https://sourceforge.net/p/libtorrent/mailman/libtorrent-discuss/">mailing list archive</a></td>
      <td><a href="contributing.html">contributing</a></td>
      <td><a href="streaming.html">streaming</a></td>
    </tr>
    <tr>
      <td><a href="https://github.com/arvidn/libtorrent/issues">report a bug</a></td>
      <td><a href="building.html">building</a></td>
      <td><a href="bittorrent.pdf">bittorrent slides</a></td>
    </tr>
    </table>
    </div>
    <div id="filler"></div>

</div>
</body>
</html>
